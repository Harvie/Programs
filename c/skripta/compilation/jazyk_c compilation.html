<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0077)http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml -->
<HTML xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs" lang="cs" dir="ltr"><STYLE>#gview-cmenu {
  position: absolute;
  border: 1px solid #ccc;
  background: #fff;
  margin: 0;
  padding: 0;
  top: 0;
  left: 0;
  z-index: 10000;
  list-style-type: none;
  -webkit-box-shadow: 0 3px 5px rgba(0, 0, 0, .5);
}

#gview-cmenu:focus {
  outline: none;
}

.gview-cmenu-item {
  margin: 0;
  padding: 5px 7px;
  cursor: default;
  font-size: 13px;
  font-family: arial, san-serif;
  color: #000;
  -webkit-user-select: none;
}

.gview-cmenu-item:hover {
  background-color: #F0F7F9;
}

.gview-cmenu-item:first-child {
  border-bottom: 1px solid #ddd;
}

.gview-hidden {
  display: none;
}
</STYLE><STYLE>.linkclass { }</STYLE><STYLE>#gview-cmenu {
  position: absolute;
  border: 1px solid #ccc;
  background: #fff;
  margin: 0;
  padding: 0;
  top: 0;
  left: 0;
  z-index: 10000;
  list-style-type: none;
  -webkit-box-shadow: 0 3px 5px rgba(0, 0, 0, .5);
}

#gview-cmenu:focus {
  outline: none;
}

.gview-cmenu-item {
  margin: 0;
  padding: 5px 7px;
  cursor: default;
  font-size: 13px;
  font-family: arial, san-serif;
  color: #000;
  -webkit-user-select: none;
}

.gview-cmenu-item:hover {
  background-color: #F0F7F9;
}

.gview-cmenu-item:first-child {
  border-bottom: 1px solid #ddd;
}

.gview-hidden {
  display: none;
}
</STYLE><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <TITLE>skripta:jazyk_c:compilation</TITLE>
<META name="generator" content="DokuWiki Release 2009-12-25c &quot;Lemming&quot;">
<META name="robots" content="noindex,nofollow">
<META name="date" content="2010-02-17T20:37:10+0100">
<META name="keywords" content="skripta,jazyk_c,compilation">
<LINK rel="search" type="application/opensearchdescription+xml" href="http://localhost/doku/lib/exe/opensearch.php" title="Harvie&#39;s Wiki">
<LINK rel="start" href="http://localhost/doku/">
<LINK rel="contents" href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=index" title="Index">
<LINK rel="alternate" type="application/rss+xml" title="Recent Changes" href="http://localhost/doku/feed.php">
<LINK rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://localhost/doku/feed.php?mode=list&ns=skripta:jazyk_c">
<LINK rel="alternate" type="text/html" title="Plain HTML" href="http://localhost/doku/doku.php?do=export_xhtml&id=skripta:jazyk_c:compilation">
<LINK rel="alternate" type="text/plain" title="Wiki Markup" href="http://localhost/doku/doku.php?do=export_raw&id=skripta:jazyk_c:compilation">
<LINK rel="canonical" href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation">
<LINK rel="stylesheet" media="all" type="text/css" href="./jazyk_c compilation_files/css.php">
<LINK rel="stylesheet" media="screen" type="text/css" href="./jazyk_c compilation_files/css(1).php">
<LINK rel="stylesheet" media="print" type="text/css" href="./jazyk_c compilation_files/css(2).php">
<SCRIPT type="text/javascript" charset="utf-8"><!--//--><![CDATA[//><!--
var NS='skripta:jazyk_c';var SIG=' --- //[[harvie@email.cz|Tomáš Mudruňka]] 2010/02/17 20:38//';var JSINFO = {"id":"skripta:jazyk_c:compilation","namespace":"skripta:jazyk_c"};
//--><!]]></SCRIPT>
<SCRIPT type="text/javascript" charset="utf-8" src="./jazyk_c compilation_files/js.php"></SCRIPT>
<STYLE type="text/css">.favicon {padding-right:4px; vertical-align:middle; border:none;}     li.w0 {position:relative;}     .l .favicon {left:-6px; position:absolute; top:2px;}     li.g {position:relative; padding-left:20px}</STYLE></HEAD><BODY>
<DIV class="dokuwiki export">
<!-- TOC START -->
<DIV class="toc">
<DIV class="tocheader toctoggle" id="toc__header" style="cursor: pointer; "><SPAN id="toc__toggle" style="cursor: pointer; " class="toc_close"><SPAN>−</SPAN></SPAN>Obsah</DIV>
<DIV id="toc__inside">

<UL class="toc">
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#predmluva" class="toc">Předmluva</A></SPAN></DIV></LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#rozpis_lekci" class="toc">Rozpis lekcí</A></SPAN></DIV></LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#co_bychom_meli_znat_nez_zacneme_programovat" class="toc">Co bychom měli znát než začneme programovat</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#predmluva1" class="toc">Předmluva</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#pocatky" class="toc">Počátky</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#proc_c" class="toc">Proč C?</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#historie_jazyka_c" class="toc">Historie jazyka C</A></SPAN></DIV>
<UL class="toc">
<LI class="level3"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#pocatky1" class="toc">Počátky</A></SPAN></DIV></LI>
<LI class="level3"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#k_r_c" class="toc">K&amp;R C</A></SPAN></DIV></LI>
<LI class="level3"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#ansi_c_a_iso_c" class="toc">ANSI C a ISO C</A></SPAN></DIV></LI>
<LI class="level3"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#c99" class="toc">C99</A></SPAN></DIV></LI>
</UL>
</LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#ahoj_svete" class="toc">Ahoj, světe!</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#rozbor_prvniho_programu" class="toc">Rozbor prvního programu</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#co_budeme_potrebovat_pro_psani_a_spusteni_programu_v_c" class="toc">Co budeme potřebovat pro psaní a spuštění programů v C</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatne_cviceni" class="toc">Samostatné cvičení</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#datove_typy_deklarace_identifikatory_prirazeni_inicializace_definice" class="toc">Datové typy, deklarace, identifikátory, přiřazení, inicializace, definice</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#zakladni_jednoduche_datove_typy" class="toc">Základní jednoduché datové typy</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#deklarace_identifikatory" class="toc">Deklarace, identifikátory</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#prirazeni_inicializace" class="toc">Přiřazení, inicializace</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#definice" class="toc">Definice</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#funkce_printf_podrobneji" class="toc">Funkce printf() podrobněji</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatne_cviceni1" class="toc">Samostatné cvičení</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#vyhody_a_nevyhody_programovani_textovych_aplikaci" class="toc">Výhody a nevýhody programování textových aplikací</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#pokud_v_c_piseme_konzolove_aplikace_ziskame_tyto_vyhody" class="toc">Pokud v C píšeme konzolové aplikace, získáme tyto výhody:</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#nevyhody_textovych_programu" class="toc">Nevýhody textových programů</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#vyhody_grafickych_aplikaci" class="toc">Výhody grafických aplikací</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#nevyhody_grafickych_aplikaci" class="toc">Nevýhody grafických aplikací</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#guibuildery_-_prostredi_pro_jednoduchy_navrh_grafickeho_rozhrani_programu_v_c_c" class="toc">GUIBuildery - prostředí pro jednoduchý návrh grafického rozhraní programů v C/C++</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#konstanty_konstantni_promenne" class="toc">Konstanty, konstantní proměnné</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#typy_konstant_s_okomentovanym_prikladem" class="toc">Typy konstant s okomentovaným příkladem</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#moznosti_zapisu_celych_cisel_priklady" class="toc">Možnosti zápisu celých čísel (příklady)</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#moznosti_zapisu_znaku_literaly_-_plati_i_pro_retezce" class="toc">Možnosti zápisu znaků (literály - platí i pro řetězce)</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#specialni_znaky" class="toc">Speciální znaky</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#priklady_literalu" class="toc">Příklady literálů</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#konstantni_promenne" class="toc">Konstantní proměnné</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#zakladni_operatory" class="toc">Základní operátory</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#priklad" class="toc">Příklad</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#prehled_operatoru" class="toc">Přehled operátorů</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#porovnavani" class="toc">Porovnávání</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#priklady" class="toc">Příklady</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#inkrementace_dekrementace" class="toc">Inkrementace, dekrementace,...</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#operator_sizeof" class="toc">Operátor sizeof()</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatne_cviceni2" class="toc">Samostatné cvičení</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#standartni_vstup_a_vystup" class="toc">Standartní vstup a výstup</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#radkovy_vystup" class="toc">Řádkový výstup</A></SPAN></DIV>
<UL class="toc">
<LI class="level3"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#vstup" class="toc">Vstup</A></SPAN></DIV></LI>
<LI class="level3"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#prevod_retezce_na_cislo" class="toc">Převod řetězce na číslo</A></SPAN></DIV></LI>
<LI class="level3"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#souhrnne_priklady" class="toc">Souhrnné příklady</A></SPAN></DIV></LI>
<LI class="level3"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#dalsi_prevody" class="toc">Další převody</A></SPAN></DIV></LI>
<LI class="level3"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#reseny_priklad" class="toc">Řešený příklad</A></SPAN></DIV></LI>
<LI class="level3"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#presmerovani_vstupu_a_vystupu" class="toc">Přesměrování vstupu a výstupu</A></SPAN></DIV></LI>
<LI class="level3"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatna_cviceni" class="toc">Samostatná cvičení</A></SPAN></DIV></LI>
</UL>
</LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#podminky_a_cykly" class="toc">Podmínky a cykly</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#podminka" class="toc">Podmínka</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#slozeny_prikaz_blok_kodu" class="toc">Složený příkaz (Blok kódu)</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#cyklus_while" class="toc">Cyklus while</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#cyklus_for" class="toc">Cyklus for</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#vnorene_zahnizdene_cykly" class="toc">Vnořené (zahnízděné) cykly</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#reseny_priklad1" class="toc">Řešený příklad</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatna_cviceni1" class="toc">Samostatná cvičení</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#pole" class="toc">Pole</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#priklad1" class="toc">Příklad</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#ulozeni_pole_v_pameti" class="toc">Uložení pole v paměti</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#zjisteni_velikosti_pole" class="toc">Zjištění velikosti pole</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#n-rozmerna_pole" class="toc">N-rozměrná pole</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#reseny_priklad_-_zpracovani_pole_v_cyklu" class="toc">Řešený příklad - zpracování pole v cyklu</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatna_cviceni2" class="toc">Samostatná cvičení</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#argumenty_programu" class="toc">Argumenty programu</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#argumenty_z_hlediska_programatora" class="toc">Argumenty z hlediska programátora</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#padam_padas_padame" class="toc">Padám, padáš, padáme!</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#reseny_priklad2" class="toc">Řešený příklad</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#vystup_programu" class="toc">Výstup programu:</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatna_cviceni3" class="toc">Samostatná cvičení</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#preprocesor" class="toc">Preprocesor</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#inkludovani_-_vkladani_jineho_souboru" class="toc">Inkludování - vkládání jiného souboru</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#symbolicke_konstanty" class="toc">Symbolické konstanty</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#makra" class="toc">Makra</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#podmineny_preklad_podminky_preprocesoru" class="toc">Podmíněný překlad (podmínky preprocesoru)</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#preddefinovane_symbolicke_konstanty_preprocesoru" class="toc">Předdefinované symbolické konstanty preprocesoru</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#funkce_-_uvod" class="toc">Funkce - úvod</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#volani_funkce" class="toc">Volání funkce</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#definice_funkce" class="toc">Definice funkce</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#pravidla" class="toc">Pravidla</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#parametry_funkce" class="toc">Parametry funkce</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#navratova_hodnota" class="toc">Návratová hodnota</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#cviceni" class="toc">Cvičení</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatna_cviceni4" class="toc">Samostatná cvičení</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#globalni_promenne_pretezovani_funkci_funkcni_prototypy_rekurzivni_funkce" class="toc">Globální proměnné, přetěžování funkcí, funkční prototypy, rekurzivní funkce</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#globalni_promenna" class="toc">Globální proměnná</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#pretezovani_funkci" class="toc">Přetěžování funkcí</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#funkcni_prototypy" class="toc">Funkční prototypy</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#rekurzivni_funkce" class="toc">Rekurzivní funkce</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatna_cviceni5" class="toc">Samostatná cvičení</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#referencovani" class="toc">Referencování</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#dereferencovani" class="toc">Dereferencování</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#neopravneny_pristup_do_pameti" class="toc">Neoprávněný přístup do paměti</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#spravna_deklarace_pointeru" class="toc">Správná deklarace pointerů</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#dynamicka_alokace_pameti" class="toc">Dynamická alokace paměti</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#funkce_pro_dynamicke_pridelovani_pameti" class="toc">Funkce pro dynamické přidělování paměti</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#funkce_malloc" class="toc">Funkce malloc()</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#funkce_free" class="toc">Funkce free()</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#kam_se_starym_smetim" class="toc">Kam se starým smetím?</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#opakovaci_ukazka_pointeru_a_dynamicke_alokace_pameti" class="toc">Opakovací ukázka pointerů a dynamické alokace paměti</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#dynamicka_pole" class="toc">Dynamická pole</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#alokace" class="toc">Alokace</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#pokrocile_postupy" class="toc">Pokročilé postupy</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#preteceni_bufferu" class="toc">Přetečení bufferu</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatna_cviceni6" class="toc">Samostatná cvičení</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#spousteni_externich_programu" class="toc">Spouštění externích programů</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#funkce_system" class="toc">Funkce system()</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#dalsi_funkce_pro_praci_s_externimi_programy" class="toc">Další funkce pro práci s externími programy</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#prace_s_promennymi_prostredi" class="toc">Práce s proměnnými prostředí</A></SPAN></DIV></LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#vetveni_procesu_paralelni_zpracovani_programu" class="toc">Větvení procesu, paralelní zpracování programu</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#funkce_fork" class="toc">Funkce fork()</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#thready" class="toc">Thready</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatna_cviceni7" class="toc">Samostatná cvičení</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#prace_se_soubory" class="toc">Práce se soubory</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#otevreni_souboru" class="toc">Otevření souboru</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#rezimy_fopen" class="toc">Režimy fopen()</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#funkce_na_cteni_ze_souboru_r" class="toc">Funkce na čtení ze souboru ("r")</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#funkce_na_zapis_do_souboru_w_a" class="toc">Funkce na zápis do souboru ("w", "a")</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#predotevrene_soubory" class="toc">Předotevřené soubory</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#samostatna_cviceni8" class="toc">Samostatná cvičení</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#napojeni_na_webove_aplikace_cgi_a_php" class="toc">Napojení na webové aplikace (CGI a PHP)</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#common_gateway_interface_cgi" class="toc">Common Gateway Interface (CGI)</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#wrapper_v_php" class="toc">Wrapper v PHP</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#jine_systemy" class="toc">Jiné systémy</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#freestyle_coding_contest" class="toc">Freestyle Coding Contest</A></SPAN></DIV>
<UL class="toc">
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#kalkulator" class="toc">Kalkulátor</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#interpreter_jednoducheho_jazyka" class="toc">Interpreter jednoduchého jazyka</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#shell" class="toc">Shell</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#mnohojazycna_aplikace" class="toc">Mnohojazyčná aplikace</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#engine_textove_hry" class="toc">Engine textové hry</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#primitivni_textovy_editor" class="toc">Primitivní textový editor</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#ascii_grafika" class="toc">Ascii Grafika</A></SPAN></DIV></LI>
<LI class="level2"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#dalsi_napady" class="toc">Další nápady</A></SPAN></DIV></LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#vysvetlivky" class="toc">Vysvětlivky</A></SPAN></DIV></LI>
<LI class="level1"><DIV class="li"><SPAN class="li"><A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:compilation&do=export_xhtml#prameny" class="toc">Prameny</A></SPAN></DIV></LI></UL>
</DIV>
</DIV>
<!-- TOC END -->
<PRE class="code">     _                 _       ____
    | | __ _ _____   _| | __  / ___|
 _  | |/ _` |_  / | | | |/ / | |
| |_| | (_| |/ /| |_| |   &lt;  | |___
 \___/ \__,_/___|\__, |_|\_\  \____|
                 |___/


	Jazyk C
	Základy praktického programování

	V Praze 2oo7 pro SSPŠ
	Tomáš Harvie Mudruňka a kolektiv</PRE>

<P>

<IMG src="./jazyk_c compilation_files/todo.gif" class="middle" alt="TODO"> mergnout adresare c a sbirka do wiki…
</P>



<H1><A name="predmluva" id="predmluva">Předmluva</A></H1>
<DIV class="level1">

<P>
Tento text vznikl puvodne jako skripta pro Smíchovskou Střední Průmyslovou Školu, nyní ho v jeho vlastním zájmu chci publikovat na wiki, kde je volně k použití i k editaci…
</P>

<P>
Skripta si nekladou za cil byt dokonalou referencni priruckou, ani wiki o jazyce C, ucelem je vytvorit ucebni texty pro jednotlive lekce kurzu programovani v jazyce C v rozsahu stravitelnem studenty stredni skoly.
</P>

<P>
<STRONG>Se skripty v celém rozsahu můžete zatím nakládat v souladu s licencí
<A href="http://creativecommons.org/licenses/by-nc-sa/3.0/cz/" class="urlextern" title="http://creativecommons.org/licenses/by-nc-sa/3.0/cz/" rel="nofollow">Creative Commons: Uveďte autora-Neužívejte dílo komerčně-Zachovejte licenci 3.0 Česko</A></STRONG>
</P>

<P>
Kromě plaintextové verze mám v plánu text vyexportovat také do následujících formátů
</P>
<UL>
<LI class="level1"><DIV class="li"> <ACRONYM title="Portable Document Format">PDF</ACRONYM></DIV>
</LI>
<LI class="level1"><DIV class="li"> <ACRONYM title="HyperText Markup Language">HTML</ACRONYM></DIV>
</LI>
<LI class="level1"><DIV class="li"> nroff (manuálové stránky)</DIV>
</LI>
</UL>

<P>

<EM>~~Tomáš Mudruňka~~</EM>

</P>

</DIV>
<!-- SECTION "Předmluva" [387-1215] -->
<H1><A name="rozpis_lekci" id="rozpis_lekci">Rozpis lekcí</A></H1>
<DIV class="level1">
<OL>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_00" class="wikilink1" title="skripta:jazyk_c:c_00">Co bychom měli znát...</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_01" class="wikilink1" title="skripta:jazyk_c:c_01">Předmluva, Něco málo o C</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_02" class="wikilink1" title="skripta:jazyk_c:c_02">Hello World!</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_03" class="wikilink1" title="skripta:jazyk_c:c_03">Proměnné, printf()</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_04" class="wikilink1" title="skripta:jazyk_c:c_04">Výhody a nevýhody programování textových aplikací (Agitační materiál ;)</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_05" class="wikilink1" title="skripta:jazyk_c:c_05">Konstanty</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_06" class="wikilink1" title="skripta:jazyk_c:c_06">Základní operátory</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_07" class="wikilink1" title="skripta:jazyk_c:c_07">Standartní vstup a výstup</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_08" class="wikilink1" title="skripta:jazyk_c:c_08">Podmínky a cykly</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_09" class="wikilink1" title="skripta:jazyk_c:c_09">Statická pole</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_10" class="wikilink1" title="skripta:jazyk_c:c_10">Argumenty programu</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_11" class="wikilink1" title="skripta:jazyk_c:c_11">Preprocesor</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_12" class="wikilink1" title="skripta:jazyk_c:c_12">Funkce - úvod</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_13" class="wikilink1" title="skripta:jazyk_c:c_13">Funkce - pokračování, Globální proměnné</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_14" class="wikilink1" title="skripta:jazyk_c:c_14">Pointery</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_15" class="wikilink1" title="skripta:jazyk_c:c_15">Dynamická alokace paměti</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_16" class="wikilink1" title="skripta:jazyk_c:c_16">Dynamická pole</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_17" class="wikilink1" title="skripta:jazyk_c:c_17">Některé funkce OS</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_18" class="wikilink1" title="skripta:jazyk_c:c_18">Práce se soubory</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_19" class="wikilink1" title="skripta:jazyk_c:c_19">Napojení C na další systémy</A></DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_20" class="wikilink1" title="skripta:jazyk_c:c_20">Zadání samostatné práce</A> →možno využít při suplování←</DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://localhost/doku/doku.php?id=skripta:jazyk_c:c_98" class="wikilink1" title="skripta:jazyk_c:c_98">Odborné a slangové pojmy, Prameny</A></DIV>
</LI>
</OL>

</DIV>
<!-- SECTION "Rozpis lekcí" [1216-2109] -->
<H1><A name="co_bychom_meli_znat_nez_zacneme_programovat" id="co_bychom_meli_znat_nez_zacneme_programovat">Co bychom měli znát než začneme programovat</A></H1>
<DIV class="level1">
<UL>
<LI class="level1"><DIV class="li"> Povinné</DIV>
<UL>
<LI class="level2"><DIV class="li"> 1B (byte) == 8b (bitů) + další základní výpočty s jednotkami informace/paměti</DIV>
</LI>
<LI class="level2"><DIV class="li"> základní práce s operačním systémem používaným k výuce</DIV>
</LI>
<LI class="level2"><DIV class="li"> práce s příkazovým řádkem (CLI) na tomto <ACRONYM title="Operating System">OS</ACRONYM> (procházení adresářů, mazání, přejmenování a kopírování souborů, nastavování práv pro spouštění, spouštění programů)</DIV>
</LI>
<LI class="level2"><DIV class="li"> základy programování z jiného jazyka (cokoli, v nejhorším případě alespoň nějaký značkovací jazyk, jako html, nebo BASIC, který se vyučuje u nás na škole)</DIV>
</LI>
</UL>
</LI>
</UL>
<UL>
<LI class="level1"><DIV class="li"> Nepovinné</DIV>
<UL>
<LI class="level2"><DIV class="li"> psaní na klávesnici (především umístění různých speciálních znaků)</DIV>
</LI>
</UL>
</LI>
</UL>

<P>

<STRONG>Ohledně jakékoli nejasnosti ohledně čehokoli se prosím kdykoli informujte u vyučujícího („když už tu teda trčíme…“).</STRONG>
</P>

<P>
Také nezapomeňte připomenout svému lektorovi, aby nezapoměl, že nemá zapomenout vám ukázat doplňkové studijní materiály, připravil jsem si pro vás totiž zábavná videa a animace <IMG src="./jazyk_c compilation_files/icon_smile.gif" class="middle" alt=":-)">

</P>

</DIV>
<!-- SECTION "Co bychom měli znát než začneme programovat" [2110-3161] -->
<H2><A name="predmluva1" id="predmluva1">Předmluva</A></H2>
<DIV class="level2">

<P>
Účelem této příručky je přiblížit vám základy programování hned z několika pohledů:
</P>
<UL>
<LI class="level1"><DIV class="li"> První složkou jsou základy praktického programování v ANSI C (napsat, zkompilovat, spustit, upravit).</DIV>
</LI>
<LI class="level1"><DIV class="li"> Dále se také seznámíme s programátorskou kulturou a základy slušného chování při získávání informací na internetu.</DIV>
</LI>
<LI class="level1"><DIV class="li"> A nakonec prohloubíme své znalosti o počítači, operačním systému a zužitkujeme nové poznatky při programování.</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Předmluva" [3162-3659] -->
<H2><A name="pocatky" id="pocatky">Počátky</A></H2>
<DIV class="level2">

<P>
Vývoj jazyka C začal v Bellových laboratořích AT&amp;T mezi léty 1969 a 1973. Ritchie tvrdí, že nejpřínosnější období bylo v roce 1972. Pojmenování „C“ zvolili, protože mnoho vlastností přebírali ze staršího jazyka zvaného „B“, jehož název byl zase odvozen od jazyka BCPL (ale to není jisté, neboť Thompson také vytvořil jazyk Bon na poctu své ženy Bonnie).
</P>

<P>
V roce 1973 se stal jazyk C dostatečně stabilním. Většina zdrojového kódu jádra Unixu, původně napsaného v assemleru PDP-11, byla přepsána do C. Unix tedy patří mezi první operační systémy, které byly napsané v jiném než strojovém jazyce či assembleru. Předchozí byl například systém Multics (napsaný v PL/I) a TRIPOS (napsaný v BCPL).ovat, opravit - to vše pokud možno nezávisle na platformě).
</P>
<UL>
<LI class="level1"><DIV class="li"> Dále se podíváme na vyhledávání informací, řešení problémů pomocí internetového vyhledávače a na programátorskou kulturu (Pokud komunikujeme s jinými programátory -byť jen po internetu-, musíme dodržovat jisté konvence. Největší a nejméně snadno dodržiteknou je nechtít po někom to, aby někdo mrhal svým časem nad něčím, co můžete udělat sami). Do této esence patří samozřejmě také konvence ve psaní zdrojového kódu a programování vůbec.</DIV>
</LI>
<LI class="level1"><DIV class="li"> A nakonec prohloubíme své znalosti ANSI C, to především znamená, že se podíváme se na pointery (ukazatele) a dynamickou alokaci paměti.</DIV>
</LI>
</UL>

<P>

Protože C je velmi komplikovaný jazyk, budeme se držet základů a věcí nezbytných k tomu, abychom měli kompaktní soubor znalostí vhodných k tomu, abychom napsali nějaký pěkný program.
</P>

</DIV>
<!-- SECTION "Počátky" [3660-5345] -->
<H2><A name="proc_c" id="proc_c">Proč C?</A></H2>
<DIV class="level2">

<P>
C je programovací jazyk, který vyvinuli Ken Thompson a Dennis Ritchie pro potřeby operačního systému Unix. V současné době je to jeden z nejpopulárnějších jazyků, zřejmě nejčastější pro psaní systémového softwaru, ale velmi rozšířený i pro aplikace.
</P>

<P>
C je nízkoúrovňový, kompilovaný, relativně minimalistický a rychlý programovací jazyk. Je dostatečně mocný na většinu systémového programování, mimoto podporuje také možnost využít ve zdrojovém kódu jazyk assembler, který pracuje víceméně s instrukcemi procesoru pro případ, že by něco (velmi nízkoúrovňového) nebylo možné napsat, to ale pro naše účely nebudeme potřebovat.
</P>

<P>
Z toho vyplývá, že operační systémy, překladače, knihovny a interpretry vysokoúrovňových jazyků jsou často implementovány právě v C.
</P>

<P>
Ukládání dat je v C řešeno třemi základními způsoby: statickou alokací paměti (při překladu), automatickou alokací paměti na zásobníku, dynamickou alokací na haldě (heap) pomocí knihovních funkcí. Jazyk nedisponuje žádnou abstrakcí nad alokací: s pamětí se pracuje přes datový typ zvaný ukazatel, který drží odkaz na paměť, ale je na něm možné provádět aritmetické operace. Ukazatelé tedy existují nezávisle na proměnných, na které odkazují, a je na odpovědnosti programátora, aby neukazovaly na paměť nealokovanou.
</P>

<P>
Jazyky Java a C#, oba odvozené od C, používají méně univerzální způsob odkazování alokovaných proměnných, který snižuje pravděpodobnost chyby v programu. Jazyk C++, původně rozšíření jazyka C, si ovšem ukazatele zachoval.
</P>

<P>
Mnoho dalších moderních programovacích jazyků (Nejen kompilovaných) přebírá způsob zápisu (neboli syntaxi) z jazyka C. Patří mezi ně například zmíněná Java či <ACRONYM title="Practical Extraction and Report Language">Perl</ACRONYM> a <ACRONYM title="Hypertext Preprocessor">PHP</ACRONYM>.
</P>

<P>
Dalším plusem je, že se při výuce a psaní programů v C se můžete naučit mnoho podrobností o funkci počítače a rozšířit je na víc než „Tam ten procesor tam počítá s nějakejma číslama a něco si dává někam do paměti“, C vám ukáže, jak funguje práce s pamětí, pokud se blíže podíváme na strojový kód (vzniklý kompilací zdrojového kódu) dozvíme se podrobněji jak funguje procesor a také specifika konkrétní architektury.
</P>

<P>
V C můžeme nejen psát textové nebo grafické aplikce, ale dokonce programovat webové aplikace podobně, jako například v <ACRONYM title="Hypertext Preprocessor">PHP</ACRONYM>, nebo dokonce psát programy pro jednočipové mikropočítače (šváby).
</P>

</DIV>
<!-- SECTION "Proč C?" [5346-7897] -->
<H2><A name="historie_jazyka_c" id="historie_jazyka_c">Historie jazyka C</A></H2>
<DIV class="level2">

</DIV>
<!-- SECTION "Historie jazyka C" [7898-7927] -->
<H3><A name="pocatky1" id="pocatky1">Počátky</A></H3>
<DIV class="level3">

<P>
Vývoj jazyka C začal v Bellových laboratořích AT&amp;T mezi léty 1969 a 1973. Ritchie tvrdí, že nejpřínosnější období bylo v roce 1972. Pojmenování „C“ zvolili, protože mnoho vlastností přebírali ze staršího jazyka zvaného „B“, jehož název byl zase odvozen od jazyka BCPL (ale to není jisté, neboť Thompson také vytvořil jazyk Bon na poctu své ženy Bonnie).
</P>

<P>
V roce 1973 se stal jazyk C dostatečně stabilním. Většina zdrojového kódu jádra Unixu, původně napsaného v assemleru PDP-11, byla přepsána do C. Unix tedy patří mezi první operační systémy, které byly napsané v jiném než strojovém jazyce či assembleru. Předchozí byl například systém Multics (napsaný v PL/I) a TRIPOS (napsaný v BCPL).
</P>

</DIV>
<!-- SECTION "Počátky" [7928-8711] -->
<H3><A name="k_r_c" id="k_r_c">K&amp;R C</A></H3>
<DIV class="level3">

<P>
V roce 1978, Ritchie a Brian Kernighan vydali první vydání knihy The C Programming Language. Tato kniha, mezi programátory C známá jako „K&amp;R“, sloužila po mnoho let jako neformální specifikace jazyka. Verze C, kterou takto popsali, bývá označována jako „K&amp;R C“. (Druhé vydání knihy popisovalo novější standard ANSI C.)
</P>

<P>
K&amp;R C je považován za základní normu, kterou musejí obsahovat všechny překladače jazyka C. Ještě mnoho let po uvedení ANSI C to byl „nejmenší společný jmenovatel“, který využívali programátoří v jazyce C kvůli maximální přenositelnosti, protože zdaleka ne všechny překladače plně podporovaly ANSI C.
</P>

<P>
V několika letech následujících po uvedení K&amp;R C bylo uvedeno a přidáno několik „neoficiálních“ vlastností jazyka, které byly podporovány překladači od AT&amp;T a některých dalších dodavatelů.
</P>

</DIV>
<!-- SECTION "K&R C" [8712-9623] -->
<H3><A name="ansi_c_a_iso_c" id="ansi_c_a_iso_c">ANSI C a ISO C</A></H3>
<DIV class="level3">

<P>
V pozdních sedmdesátých letech začalo C nahrazovat BASIC jako přední programovací jazyk pro mikropočítače. Během osmdesátých let bylo přejato pro použití na platformě IBM PC a jeho popularita se značně zvýšila. Tou dobou Bjarne Stroustrup a další v Bellových laboratořích začali pracovat na rozšiřování C o objektově orientované prvky. Jazyk, který vytvořili, zvaný C++, je dnes nejrozšířenější programovací jazyk pro aplikace na Microsoft Windows. C zůstává stále populárnější ve světě Unixu.
</P>

<P>
Jedním z cílů standardizačního procesu ANSI C byl vytvořit nadmnožinu K&amp;R C zahrnující mnoho „neoficiálních vlastností“. Navíc standardizační komise přidala několik vlastností jako funkční prototypy (vypůjčené z C++) a schopnější preprocesor.
</P>

<P>
ANSI C je dnes podporováno téměř všemi rozšířenými překladači. Většina kódu psaného v současné době v C je založena na ANSI C. Jakýkoli program napsaný pouze ve standardním C je přeložitelný a spustitelný na jakékoli platformě, která odpovídá tomuto standardu. Nicméně mnoho programů se dá přeložit pouze na jedné platformě nebo jedním překladačem, kvůli (i) použití nestandadních knihoven, např. pro grafiku, a také (ii) některé překladače v implicitním módu neodpovídají standardu ANSI C.
</P>

</DIV>
<!-- SECTION "ANSI C a ISO C" [9624-11018] -->
<H3><A name="c99" id="c99">C99</A></H3>
<DIV class="level3">

<P>
Po standardizaci jazyka v roce 1989 se většina vývoje soustředila na jazyk C++. Přesto však na konci 90. let došlo k vydání dokumentu <ACRONYM title="International Organization for Standardization">ISO</ACRONYM> 9899:1999 (obvykle nazývaný C99), který byl následně v březnu 2000 přijat i jako ANSI standard.
</P>

<P>
C99 představil několik nových vlastností, které byly mnohdy v překladačích už implementovány jako rozšíření.
</P>

<P>
Standard C99 je v některých ohledech přísnější než původní standard C89; například je zakázáno odkazovat na stejnou paměť ukazateli jiných typů. Toto umožňuje vylepšenou optimalizaci, ale může způsobit problémy s kompilací starších programů.
</P>

<P>
Žádný kompilátor zatím neobsahuje kompletní implementaci C99, přestože některé jsou poměrně blízko (GCC). Firmy jako Microsoft nebo Borland neprojevily velký zájem o implementaci C99, především kvůli tomu, že většinu nových vlastností poskytuje C++ a to často nekompatibilně s C99 (datový typ complex v C99 versus třída complex v C++).
</P>

</DIV>
<!-- SECTION "C99" [11019-12046] -->
<H1><A name="ahoj_svete" id="ahoj_svete">Ahoj, světe!</A></H1>
<DIV class="level1">

<P>
Tzv. „Ahoj, světe!“ (v originále „hello, world“) je jednoduchý program, který prostě jen vypíše „hello, world“, ten je sám o sobě prakticky k ničemu, ale pro programátory je důležitý protože se naučíme jak vypadá program, který nic vlastně nedělá, jak se zkompiluje a spustí, tedy všechny formality, které nás dělí od vlastního programování.
</P>

<P>
A takto tedy vypadá hello world v C:
</P>
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=0" title="St&aacute;hnout snippet" class="mediafile mf_c">hello.c</A></DT>
<DD><PRE class="code file c">  <SPAN class="co2">#include &lt;stdio.h&gt;</SPAN>
&nbsp;
  <SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> argc<SPAN class="sy0">,</SPAN> <SPAN class="kw4">char</SPAN> <SPAN class="sy0">*</SPAN>argv<SPAN class="br0">[</SPAN><SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN> <SPAN class="co1">//Pro primitivni programy muzeme pouzit jen: int main(void)</SPAN>
  <SPAN class="br0">{</SPAN>
    <SPAN class="co1">//Toto je komentar</SPAN>
    <SPAN class="coMULTI">/* 
     * A toto je
     * viceradkovy komentar
     */</SPAN>
    <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"hello, world<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
    <SPAN class="kw1">return</SPAN><SPAN class="br0">(</SPAN>0<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
  <SPAN class="br0">}</SPAN></PRE>
</DD></DL>

<P>

Tento text uložíme pomocí nejobyčejnějšího textového editoru do souboru s příponou .c (tedy např.: „hello.c“). Na konci souboru musí být minimálně jeden prázdný řádek a soubor nesmí končit v otevřeném komentáři tedy např.: “/*Za touto vetou bude konec souboru“. Jinak kompilátor (nebo spíše preprocesor) nahlásí chybu.
</P>

</DIV>
<!-- SECTION "Ahoj, světe!" [12047-13120] -->
<H2><A name="rozbor_prvniho_programu" id="rozbor_prvniho_programu">Rozbor prvního programu</A></H2>
<DIV class="level2">

<P>
Po kompilaci a spuštění tohoto programu začne počítač vykonávat naše příkazy tak, jak jsou napsány ze shora dolů, z leva do prava. Teď si ukážeme co program udělá krok za krokem, řádek po řádku:

</P>
<PRE class="code">#include &lt;stdio.h&gt;</PRE>

<P>
To není příkaz, který by se prováděl při spuštění programu, ale ještě před kompilací. Jde o tzv. „direktivu preprocesoru“ (začínají # - křížkem), preprocesor je program, který připraví náš kód pro kompilátor (odstraní nepotřebné mezery, prázdné řádky, rozvine makra,…). Direktiva preprocesoru #include &lt;soubor&gt; způsobí to, že bude nahrazena obsahem souboru „soubor“, čili na začítek našeho programu se vloží soubor stdio.h, který obsahuje především funkce na práci s příkazovým řádkem a soubory. Pokud je jméno souboru ve špičatých závorkách (#include &lt;soubor&gt;), hledá se soubor v adresáři pro hlavičkové soubory, který je součástí kompilátoru, pokud bychom napsali jméno souboru mezi uvozovky (#include „soubor“), preprocesor by hledal soubor ve stejném adresáři, jako se nachází náš program.

</P>
<PRE class="code">int main(int argc,char *argv[]) { /*Nase prikazy...*/ }</PRE>

<P>
Toto je deklarace funkce main, funkce main je první funkce, která je zavolána po spuštění programu, jinými slovy příkazy uvedené ve složených závorkách ({}) budou provedeny neprodleně po spuštění našeho programu. Klíčové slovo „int“ před jménem funkce říká, že funkce vrací integer (tedy celé číslo). Dvě proměnné nadeklarované v závorkách za jménem funkce (int argc, char *argv[]) se používají k získání parametrů od našeho <ACRONYM title="Operating System">OS</ACRONYM>, jde o argumenty z příkazové řádky (nebo třeba jména souborů přetažená na ikonku našeho programu). přičemž celé číslo argc obsahuje počet parametrů a pole řetězců (polí znaků) argv[] obsahuje text těchto argumentů.

</P>
<PRE class="code">/* Komentáře */</PRE>

<P>
Vše, co je umístěno mezi /* a */ (v našem příkladu můžete vidět zdobnější zápis s hvězdičkou na každé řádce, to zůstává na fantazii programátora…) bude ignorováno, můžeme to tedy použít pro popisování našich programů (to je velmi důležité, jinak se v našem programu ztratíme). Také můžeme použít komentář pomocí <EM> , kdy vše od </EM> až do konce řádku je ignorováno.

</P>
<PRE class="code">printf("hello, world\n");</PRE>

<P>
Tento řádek vypíše na obrazovku text „hello, world“ a přejde na nový řádek („\n“ značí newline dle zvyku na vašem <ACRONYM title="Operating System">OS</ACRONYM>, tj. ekvivalent enteru). Funkce printf() je nadefinovaná v souboru stdio.h (viz. výše) a jako první parametr přijímá text, který chceme vypsat, nebo formátovací řetězec. Tímto prvním argumentem je vždy řetězec (např. text v uvozovkách). Pokud bychom chtěli vypsat uvozovku, musíme použít \“ pokud lomítko, tak <BR>
a pokud znam procenta, tak %%. Všiměte si, že deklarace, definice a volání funkce (náš případ) musí končit středníkem (;), nikoli však novým řádkem, stačí mezera, nebo tabelátor.

</P>
<PRE class="code">return(0);</PRE>

<P>
Jde opět o volání funkce. Funkce return() (jména funkcí píšeme standartně s () na konci, aby bylo na první pohled jasné, že jde o funkci) způsobí to, že je funkcí, ze které je zavolána (v našem případě main()), vrácena hodnota zadaná jako první parametr této funkce return(). Pokud toto zavoláme z funkce main, znamená to pro nás ukončení programu s návratovou hodnotou 0. Návratové hodnoty jsou čísla (int main(), tedy funkce main() je typu integer == celé číslo), které programy předávají operačnímu systému po skončení, aby měl přehled o úspěšnosti vykonání programu (0 znamená bez chyby a obecně pak platí, že čím vyšší číslo, tím horší chyba).
</P>

<P>
Pokud program dojde na konec kódu funkce, je automaticky navrácena hodnota 0, pokud to není změněno pomocí funkce return();
</P>

</DIV>
<!-- SECTION "Rozbor prvního programu" [13121-17039] -->
<H2><A name="co_budeme_potrebovat_pro_psani_a_spusteni_programu_v_c" id="co_budeme_potrebovat_pro_psani_a_spusteni_programu_v_c">Co budeme potřebovat pro psaní a spuštění programů v C</A></H2>
<DIV class="level2">

<P>
V první řadě budeme potřebovat plaintextový editor (jsme začátečníci a budeme tedy raději konzervativní, takže kódovani utf-8, nebo cp-1250, raději žédné wide-chary a už vůbec ne textové editory typu Word!!!). Naopak se nám hodí editor se zvýrazněnou syntaxí a jinými „vychytávkami“, které nám mnohonásobně usnadní psaní kódu a například nám i napovídá, jeden z nejlepších nejuniverzálnějších editorů je SciTe (na enginu Scintilla).
</P>

<P>
Můžeme použít například editory dostupné pro náš <ACRONYM title="Operating System">OS</ACRONYM>
Microsoft:
</P>
<UL>
<LI class="level1"><DIV class="li"> SciTe (doporučuji)</DIV>
</LI>
<LI class="level1"><DIV class="li"> PSPad (nedoporučuji)</DIV>
</LI>
<LI class="level1"><DIV class="li"> notepad</DIV>
</LI>
</UL>

<P>
Unixy:
</P>
<UL>
<LI class="level1"><DIV class="li"> SciTe (doporučuji)</DIV>
</LI>
<LI class="level1"><DIV class="li"> nano (doporučuji pro příkazový řádek)</DIV>
</LI>
<LI class="level1"><DIV class="li"> mcedit (balíček mc)</DIV>
</LI>
<LI class="level1"><DIV class="li"> vim</DIV>
</LI>
</UL>

<P>

Potom budeme také potřebovat program, který převede námi psaný a čitelný strojový kód na strojový kód tj. procesorem čitelné instrukce (ty se ukládají v binárním spustitelné souboru čitelném operačním systémem). A samozřejmě standartní knihovny ANSI C (verzi pro vývojáře).
</P>

<P>
Na platformách od Microsoftu to znamená instalci jednoho z těchto balíčků
</P>
<UL>
<LI class="level1"><DIV class="li"> MinGW (gcc, g++) - (doporučuji)</DIV>
</LI>
<LI class="level1"><DIV class="li"> Borland C Compiler</DIV>
</LI>
</UL>

<P>

Na Unixových platformách pak pravděpodobně potřebujeme tyto balíčky
</P>
<UL>
<LI class="level1"><DIV class="li"> gcc</DIV>
</LI>
<LI class="level1"><DIV class="li"> g++ (pokud máme zájem také o C++)</DIV>
</LI>
<LI class="level1"><DIV class="li"> libc-dev (poslední verze)</DIV>
</LI>
</UL>

<P>

Nebo můžeme sáhnout po celých IDE (Integrované vývojové prostředí)
Jde o jakýsi balíček Vše-V-Jednom. To v praxi znamená potřebný editor uživatelsky přívětivě spolupracující s kompilátorem, jinými slovy nainstalujeme jeden balíček programů místo všech výše zmíněných.
</P>

<P>
Ze všech IDE pro Unixy i <ACRONYM title="Microsoft">MS</ACRONYM> systémy je pro nás nejvýhodnější multiplatformní IDE Dev-C++ (dev-cpp) - (doporučuji).
Pro jednotlivé systémy existují samozřejmě i další IDE:
</P>

<P>
Na Windows máme např.
</P>
<UL>
<LI class="level1"><DIV class="li"> C++ Builder</DIV>
</LI>
<LI class="level1"><DIV class="li"> Microsoft Visual Studio (nebo Visual C++)</DIV>
</LI>
</UL>

<P>

Na Unixech pak stojí za zmínku
</P>
<UL>
<LI class="level1"><DIV class="li"> Eclipse (s pluginem pro C)</DIV>
</LI>
<LI class="level1"><DIV class="li"> NetBeans (s pluginem pro C)</DIV>
</LI>
<LI class="level1"><DIV class="li"> Anjuta</DIV>
</LI>
<LI class="level1"><DIV class="li"> KDevelop</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Co budeme potřebovat pro psaní a spuštění programů v C" [17040-19144] -->
<H2><A name="samostatne_cviceni" id="samostatne_cviceni">Samostatné cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Vyberte si jedno z freewarových řešení dle výběru vyučujícího (Dev-C++, nebo SciTe s gcc/g++).</DIV>
</LI>
<LI class="level1"><DIV class="li"> Vyhledejte si ho pomocí Googlu, stáhněte a nainstalujte ho na váš počítač.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Vyzkoušejte si kompilaci a spuštění našeho prvního programu (Hello, world!).</DIV>
</LI>
<LI class="level1"><DIV class="li"> Vyzkoušejte si práci s editorem, zvýraznění syntaxe a případně automatické dokončování kódu.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Pokuste se náš program zkompilovat podruhé, ale v kódu změňte text, který se bude vypisovat na obrazovku.</DIV>
</LI>
</UL>

<P>

Následující body platí i pro všechna budoucí cvičení:
</P>
<UL>
<LI class="level1"><DIV class="li"> Veškeré problémy se pokuste vyřešit nejdříve pomocí Googlu, případně pomocí manuálu dodaného s produktem.</DIV>
</LI>
<LI class="level1"><DIV class="li"> V případě neúspěchu se obraťte na vyučujícího.</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Samostatné cvičení" [19145-19935] -->
<H1><A name="datove_typy_deklarace_identifikatory_prirazeni_inicializace_definice" id="datove_typy_deklarace_identifikatory_prirazeni_inicializace_definice">Datové typy, deklarace, identifikátory, přiřazení, inicializace, definice</A></H1>
<DIV class="level1">

<P>
Jazyk C disponuje několika základními datovými typy, jiné si můžeme vytvořit sami. Datový typ v praxi popisuje formát nějaké hodnoty, která vyžaduje alokaci předem daného místa v paměti (většinou měříme v bytech), na to se ukládá požadovaná hodnota (samozřejmě binárně), které přísluší (což není úplně tak závazné) konkrétní interpretace (logická hodnota, číslo, znak, text).
</P>

</DIV>
<!-- SECTION "Datové typy, deklarace, identifikátory, přiřazení, inicializace, definice" [19936-20453] -->
<H2><A name="zakladni_jednoduche_datove_typy" id="zakladni_jednoduche_datove_typy">Základní jednoduché datové typy</A></H2>
<DIV class="level2">

<P>
Celočíselné
</P>
<UL>
<LI class="level1"><DIV class="li"> char	- 1B</DIV>
</LI>
<LI class="level1"><DIV class="li"> short	- 2B</DIV>
</LI>
<LI class="level1"><DIV class="li"> int		- 2B</DIV>
</LI>
<LI class="level1"><DIV class="li"> long	- 4B</DIV>
</LI>
</UL>

<P>

S Plovoucí desetinnou čárkou
</P>
<UL>
<LI class="level1"><DIV class="li"> float	- 4B</DIV>
</LI>
<LI class="level1"><DIV class="li"> double	- 8B</DIV>
</LI>
<LI class="level1"><DIV class="li"> long double	- 10B</DIV>
</LI>
</UL>

<P>

<EM>pozn.: Hodnoty se mohou lišit podle konkrétní implementace (kompilátoru). Velikost konkrétního typu v bytech získáte také pomocí makra preprocesoru sizeof(), tedy např sizeof(char) bude nahrazeno číslem 1.</EM>
</P>

<P>
Například datový typ char má velikost 1B, to odpovídá 256ti možným kombinacím, standartně jednoduché datové typy počítají s možností uložení záporného čísla, takže např. char může dosahovat hodnot -128 až 127, podobné je to se všemi jednoduchými typy.
</P>

<P>
Pokud ale nechceme zbytečně alokovat (zabírat) paměť pro záporná čísla, když víme, že toho nevyužijeme, můžeme použít operátoru „unsigned“ (česky „bez znaménka“), tím docílíme toho, že se rozsah všech možných hodnot našeho typu „posune“ na 0 a výše. Např. tedy datový typ „unsigned char“ může nést hodnotu 0 až 255 tj. nějaký libovolný byte.
</P>

</DIV>
<!-- SECTION "Základní jednoduché datové typy" [20454-21551] -->
<H2><A name="deklarace_identifikatory" id="deklarace_identifikatory">Deklarace, identifikátory</A></H2>
<DIV class="level2">

<P>
Takže ve zkratce známe několik důležitých datových typů a určitě nás zajímá jejich využití. První možností je, jak již bylo naznačeno, ukládání informací do paměti. Abychom mohli ukládat data do paměti, musíme si nejprve vytvořit proměnnou (staticky-na pevno alokovat část paměti), toho docílíme jednoduchým kusem kódu, vše ostatní už vyřeší kompilátor.
</P>

<P>
Této proceduře se říká „deklarace“, to znamená, že v paměti zabereme místo a přiřadíme mu „identifikátor“ (jméno), který budeme pokaždé používat při práci s tímto prostorem v paměti (to není podmínkou, identifikátoru je totiž přiřazena nějaká konkrétní adresa v paměti, ale o tom až v pokračování pro pokročilé).
</P>

<P>
Identifikátory mohou sice obsahovat různé znaky, my se ale zatím budeme držet malých písmen (v případě potřeby lze několik slov oddělit např. podtržítkem („_“)), to nám musí stačit, také se můžeme držet některých tradic (znaky začínájí na „c“ („cmuj_znak“), proměnné používané k řízení cyklů se většinou označují pouze „i“ - může nám stačit pro celý jednodušší program bez vnořených cyklů, atd…)
</P>

<P>
A takto proběhne deklarace z pohledu programátora:
</P>
<PRE class="code">datovy_typ identifikator[, dalsi_identifikator, ...]; //Deklarace konci strednikem</PRE>

<P>

Takže pokud například potřebujeme tři proměné, pro uložení hodnot 0 - 4 294 967 295, použijeme tuto konstrukci:
</P>
<PRE class="code">unsigned int moje_cislo, moje_dalsi_cislo, moje_posledni_cislo;</PRE>

<P>

Pozor ovšem na redeklaraci - tj. pokus o opětovnou deklaraci/definici libovolné proměnné, funkce, nebo čehokoli jiného, jejíž identifikátor je již používán, to je chyba, která většinou zkončí chybou překladače (kompilátoru).
</P>

</DIV>
<!-- SECTION "Deklarace, identifikátory" [21552-23372] -->
<H2><A name="prirazeni_inicializace" id="prirazeni_inicializace">Přiřazení, inicializace</A></H2>
<DIV class="level2">

<P>
Přiřazení je operace, která na danou adresu ukládá námi vybraná data, probíhá pomocí operátoru rovnítko (“=“) levé a pravé hodnoty (l-hodnota, r-hodnota - od left, right).
</P>

<P>
Obecný zápis je tento:
</P>
<PRE class="code">l-hodnota = r-hodnota; //I prirazeni opet konci strednikem</PRE>

<P>

L-hodnota je v levo, tj. cíl přiřazení, r-hodnota je v pravo, tj hodnota přiřazení, po úspěšném přiřazení platí, že se l-hodnota rovná r-hodnotě.
Pokud bychom tedy do námi deklarované proměnné moje_cislo chtěli přiřadit hodnotu 5, postupujeme takto:
</P>
<PRE class="code">moje_cislo = 5;</PRE>

<P>

Pokud je hodnota do proměnné jednou přiřazena, lze ji samozřejmě přepsat jinou (až na vyjímky, o tom později…).
</P>

<P>
Pokud je to poprvé, co do nově nadeklarované proměnné přiřazujeme hodnotu, takovému přiřazení říkáme také inicializace.
</P>

</DIV>
<!-- SECTION "Přiřazení, inicializace" [23373-24242] -->
<H2><A name="definice" id="definice">Definice</A></H2>
<DIV class="level2">

<P>
Definice je výraz pro inicializaci provedenou zároveň při deklaraci (nebudeme polemizovat o rozdílu slov deklarace a definice z pohledu českého jazyka…).
</P>

<P>
Zápis definice je tento:
</P>
<PRE class="code">datovy_typ identifikator = nova_hodnota[, dalsi_identifikator = nova_hodnota, ...]; //Samozrejme strednik</PRE>

<P>

Konkretne napriklad takto:
</P>
<PRE class="code">unsigned char pocet_psu = 10;</PRE>

<P>

Ovšem zde se naskytuje další možnost udělat chybu a to je redeklarace:
</P>
<PRE class="code">unsigned char pocet_psu = 10;
unsigned char pocet_psu = 11; //Chybne pridani jednoho psa - pokus o redeklaraci!</PRE>

<P>
Spravny zapis je samozřejmě tento:
</P>
<PRE class="code">unsigned char pocet_psu = 10; //Definice
pocet_psu = 11; //Spravne pridani jednoho psa - pouze prirazeni</PRE>

</DIV>
<!-- SECTION "Definice" [24243-24962] -->
<H1><A name="funkce_printf_podrobneji" id="funkce_printf_podrobneji">Funkce printf() podrobněji</A></H1>
<DIV class="level1">

<P>
funkce printf nabízí kromě výpisu textu tak, jak je zadán do jejího parametru také možnost výpisu obsahu proměnných.
Pokud bychom například chtěli vypsat proměnné pocet_psu a pocet_kocek, docilime toho timpo zpusobem:

</P>
<PRE class="code">printf("Pocet psu: %d\nPocet kocek: %d\n", pocet_psu, pocet_kocek); //Ansi-C funkce ze stdio.h - Nezapomeneme na #include &lt;stdio.h&gt;!!!</PRE>

<P>

Symbol %d bude nahrazen číslem načteným z naší proměnné, s každým podobným operátorem přibyde funkci printf() jeden povinný parametr, tzn., že pokud je v našem řetězi dvakrát “%d“, musíme kromě prvního parametru (tzv. formátovacího řetězce) specifikovat ještě další dva parametry, tj. např. dvě proměnné v požadovaném pořadí.
</P>

<P>
Tady je seznam všech nejdůležitějších operátorů pro formátovací řetězec funkce printf:
</P>

<P>
Pro čísla typu int
</P>
<UL>
<LI class="level1"><DIV class="li"> %d - vypíše číslo dekadicky</DIV>
</LI>
<LI class="level1"><DIV class="li"> %u - vypíše číslo dekadicky neznaménkově (unsigned)</DIV>
</LI>
<LI class="level1"><DIV class="li"> %x - vypíše číslo hexadecimálně malými písmenky</DIV>
</LI>
<LI class="level1"><DIV class="li"> %X - vypíše číslo hexadecimálně velkými písmenky</DIV>
</LI>
<LI class="level1"><DIV class="li"> %o - vypíše číslo oktálně</DIV>
</LI>
</UL>

<P>

Pro ostatní typy
</P>
<UL>
<LI class="level1"><DIV class="li"> %ld - vypíše číslo typu long dekadicky</DIV>
</LI>
<LI class="level1"><DIV class="li"> %f  - vypíše číslo typu float dekadicky</DIV>
</LI>
<LI class="level1"><DIV class="li"> %Lf - vypíše číslo typu long double dekadicky</DIV>
</LI>
</UL>

<P>

Pro pole
</P>
<UL>
<LI class="level1"><DIV class="li"> %s - vypíše řetězec (tomu se budeme věnovat později)</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Funkce printf() podrobněji" [24963-26361] -->
<H2><A name="samostatne_cviceni1" id="samostatne_cviceni1">Samostatné cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Co vypíše následující příkaz?:</DIV>
<UL>
<LI class="level2"><DIV class="li"> <PRE class="code c"><A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Pocet psu: %d<SPAN class="es1">\n</SPAN>Pocet kocek: %d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> 34<SPAN class="sy0">,</SPAN> 5<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>
</DIV>
</LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"> Napište a zkompilujte program, který na začátku deklaruje jednu proměnnou a druhou definuje libovolným celým číslem, první proměnnou inicializujte také libovolným číslem. Pro obě proměnné si zvolte příslušné (a paměťově výhodné) datové typy. Nakonec pomocí příkazu printf() vypište na monitor tato čísla desítkově i šestnáctkově, ve formátovacím řetězci použijte několik přechodů na novou řádku, vtipný text a ještě vypište jedno číslo specifikované konstantou přímo jako argument funkce printf(). Smíte použít pouze jediné volání funkce printf(). Celý zdrojový kód progamu vhodně okomentujte.</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Samostatné cvičení" [26362-27175] -->
<H1><A name="vyhody_a_nevyhody_programovani_textovych_aplikaci" id="vyhody_a_nevyhody_programovani_textovych_aplikaci">Výhody a nevýhody programování textových aplikací</A></H1>
<DIV class="level1">

<P>
V našich seminářích se budeme zabívat především psaním aplikací pro CLI (tedy příkazový řádek).
Účelem této hodiny je poskytnout vám objektivní pohled na tyto aplikace ve srovnání s aplikacemi grafickými.
</P>

</DIV>
<!-- SECTION "Výhody a nevýhody programování textových aplikací" [27176-27474] -->
<H2><A name="pokud_v_c_piseme_konzolove_aplikace_ziskame_tyto_vyhody" id="pokud_v_c_piseme_konzolove_aplikace_ziskame_tyto_vyhody">Pokud v C píšeme konzolové aplikace, získáme tyto výhody:</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Textové aplikace jsou rychlejší.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Při vzdáleném přístupu k počítači se text (<ACRONYM title="Secure Shell">SSH</ACRONYM>/Telnet) přenáší rychleji než grafika (VNC/MST).</DIV>
</LI>
<LI class="level1"><DIV class="li"> Zkušenějším uživatelům usnadňují práci a posouvají pro ně efektivitu úplně jinam, než si BFU (běžný Franta uživatel) dokáže představit.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Bude velmi snadné, aby další aplikace/skripty mohly využívat naší aplikaci (např. je běžnou praxí, že se nejdříve napíše textová aplikace a grafika se píše až jako nástavba na ni - úplně samostatný spustitelný soubor).</DIV>
</LI>
<LI class="level1"><DIV class="li"> Veškeré výpisy programu i vstupy do něj můžeme ukládat nebo načítat do souboru, případně rovnou zpracovávat výstup jiného programu.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Tyto aplikace mohou být použity jako webové aplikace (buď jako binární <ACRONYM title="Common Gateway Interface">CGI</ACRONYM> aplikace, nebo prostřednictvím interpretovaných skriptů).</DIV>
</LI>
<LI class="level1"><DIV class="li"> Textové aplikace (především ty v čistém Ansi C) jsou snadno přenositelné na všechny platformy, pro které jsou dostupné kompilátory (Nejen Windows a Unixy, ale také obrovské množství dalších systémů).</DIV>
</LI>
<LI class="level1"><DIV class="li"> Pokud se naučíte psát textové aplikace, bude pro vás snadné vytvářet grafické aplikace pomocí tzv. GUIBuilderů známých například z vývojového prostředí Visual Basicu implementovaného Microsoftem nebo IBM. Pro více info viz. níže.</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Pokud v C píšeme konzolové aplikace, získáme tyto výhody:" [27475-28891] -->
<H2><A name="nevyhody_textovych_programu" id="nevyhody_textovych_programu">Nevýhody textových programů</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Pokud píšete aplikace pro běžné uživatele, budou pro ně neefektivní, protože neovládají příkazový řádek na potřebné úrovni.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Tyto uživatelé si samozřejmě budou stěžovat ;D (Dobrým kompromisem pro jednodušší aplikace je napsat si další program, který bude fungovat jako grafická nadstavba).</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Nevýhody textových programů" [28892-29265] -->
<H2><A name="vyhody_grafickych_aplikaci" id="vyhody_grafickych_aplikaci">Výhody grafických aplikací</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Spousta tzv. „eye-candy“ → Spokojení uživatelé</DIV>
</LI>
<LI class="level1"><DIV class="li"> Ovládání zvládne i p*blb</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Výhody grafických aplikací" [29266-29396] -->
<H2><A name="nevyhody_grafickych_aplikaci" id="nevyhody_grafickych_aplikaci">Nevýhody grafických aplikací</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Je obtížné je ovládat pomocí jiných programů a tedy nemůžeme práci s nimi potřebně automatizovat.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Jsou náročnější na systémové prostředky.</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Nevýhody grafických aplikací" [29397-29608] -->
<H2><A name="guibuildery_-_prostredi_pro_jednoduchy_navrh_grafickeho_rozhrani_programu_v_c_c" id="guibuildery_-_prostredi_pro_jednoduchy_navrh_grafickeho_rozhrani_programu_v_c_c">GUIBuildery - prostředí pro jednoduchý návrh grafického rozhraní programů v C/C++</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Borland C++ Builder (Windows)</DIV>
</LI>
<LI class="level1"><DIV class="li"> Kylix (Linux - kompatibilní s C++ Builderem a Delphy - zastaralé)</DIV>
</LI>
<LI class="level1"><DIV class="li"> Microsoft Visual Studio (Windows)</DIV>
</LI>
<LI class="level1"><DIV class="li"> wxDev-Cpp (Windows, programy ale možno kompilovat i na Linuxu s potřebnými knihovnami - wxWidgets)</DIV>
</LI>
<LI class="level1"><DIV class="li"> GLade (Linux - GTK+2)</DIV>
</LI>
<LI class="level1"><DIV class="li"> další… (cokoli, s čím se vám dobře pracuje…)</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "GUIBuildery - prostředí pro jednoduchý návrh grafického rozhraní programů v C/C++" [29609-30044] -->
<H1><A name="konstanty_konstantni_promenne" id="konstanty_konstantni_promenne">Konstanty, konstantní proměnné</A></H1>
<DIV class="level1">

<P>
Konstata je výraz pro jakákoliv data, se kterými program pracuje a píšeme je přímo do zdrojového kódu.
Konstantou může být např. číslo, znak, řetězec, pointer, a další…
Konstanta se chová jako výraz, jako R-Hodnota (lze ji přiřadit, ale nelze přiřadit do ní).
S konstantami jsme se již setkaly v kapitole probírající přiřazení.
</P>

</DIV>
<!-- SECTION "Konstanty, konstantní proměnné" [30045-30456] -->
<H2><A name="typy_konstant_s_okomentovanym_prikladem" id="typy_konstant_s_okomentovanym_prikladem">Typy konstant s okomentovaným příkladem</A></H2>
<DIV class="level2">
<PRE class="code">int	32		//cele cislo (Integer)
long	L940		//cislo typu long
float	2.345		//cislo s plovouci radovou carkou (teckou)
float	F940		//Jiny zapis floatu (bez tecky by nebylo jasne, ze jde o float)
double  3.45		//cislo double
char	'A'		//znak (pro binarni data pouzivejte unsigned char nebo lepe int)
char[] "Muj text"	//retezec - pole znaku - viz. znak</PRE>

</DIV>
<!-- SECTION "Typy konstant s okomentovaným příkladem" [30457-30875] -->
<H2><A name="moznosti_zapisu_celych_cisel_priklady" id="moznosti_zapisu_celych_cisel_priklady">Možnosti zápisu celých čísel (příklady)</A></H2>
<DIV class="level2">
<PRE class="code">decimálně	123
hexadecimálně	0x1A6F
oktálně	029</PRE>

</DIV>
<!-- SECTION "Možnosti zápisu celých čísel (příklady)" [30876-30995] -->
<H2><A name="moznosti_zapisu_znaku_literaly_-_plati_i_pro_retezce" id="moznosti_zapisu_znaku_literaly_-_plati_i_pro_retezce">Možnosti zápisu znaků (literály - platí i pro řetězce)</A></H2>
<DIV class="level2">
<PRE class="code">decimálně	\0232 ('\0232')
hexadecimálně	\x0A ('\x0A')</PRE>

</DIV>
<!-- SECTION "Možnosti zápisu znaků (literály - platí i pro řetězce)" [30996-31133] -->
<H2><A name="specialni_znaky" id="specialni_znaky">Speciální znaky</A></H2>
<DIV class="level2">
<PRE class="code">\n ('\n')	Přechod na další řádek
\r ('\r')	Přechod na začátek řádku
\t ('\t')	Tabelátor</PRE>

</DIV>
<!-- SECTION "Speciální znaky" [31134-31270] -->
<H2><A name="priklady_literalu" id="priklady_literalu">Příklady literálů</A></H2>
<DIV class="level2">
<PRE class="code">char str[] = "\tPole ch\x41ru, neboli retezec,\nje to tak.";
char str[] = "Preruseny"	" retezec\n";
char str[] = "Preruseny " "retezec "
	     "muze pokracovat i na dalsi radce!\n";</PRE>

</DIV>
<!-- SECTION "Příklady literálů" [31271-31496] -->
<H2><A name="konstantni_promenne" id="konstantni_promenne">Konstantní proměnné</A></H2>
<DIV class="level2">

<P>
Konstantní proměnná je taková proměnná, která se po inicializaci stává konstantou (nelze ji měnit, je to tedy neproměnná proměnná ;D).
Deklarace konstantní proměnné probíhá pomocí tzv. „typového modifikátoru“, v našem případě „const“.
</P>

<P>
Příklad:
</P>
<PRE class="code">const int a, b = 32; //Promenna b jiz nepujde zmenit, promenna a pujde zmenit pouze jednou (inicializovat).</PRE>

</DIV>
<!-- SECTION "Konstantní proměnné" [31497-31914] -->
<H1><A name="zakladni_operatory" id="zakladni_operatory">Základní operátory</A></H1>
<DIV class="level1">

<P>
R-hodnota (viz. dříve) se může skládat z více prvků s vlastnostmi r-hodnoty. To uděláme za pomoci nějakých operátorů, se dvěmi hodnotami můžeme provádět různé operace (aritmetické, logické a další). k tomu nám slouží různé operátory.
</P>

</DIV>
<!-- SECTION "Základní operátory" [31915-32215] -->
<H2><A name="priklad" id="priklad">Příklad</A></H2>
<DIV class="level2">
<PRE class="code c">  <SPAN class="kw4">int</SPAN> x<SPAN class="sy0">,</SPAN> a<SPAN class="sy0">,</SPAN> b <SPAN class="sy0">=</SPAN> <SPAN class="nu0">2</SPAN><SPAN class="sy0">;</SPAN>
  x <SPAN class="sy0">=</SPAN> <SPAN class="br0">(</SPAN>a <SPAN class="sy0">=</SPAN> <SPAN class="br0">(</SPAN>b <SPAN class="sy0">*</SPAN> 2<SPAN class="br0">)</SPAN> <SPAN class="sy0">-</SPAN> 3<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>

<P>

Na konci tohoto kódu budou proměnné „x“ a „a“ držet hodnotu 1.
</P>

<P>
Z toho také vyplívá, že celé přiřazení (l-hodnota = r-hodnota) je zároveň r-hodnotou a lze ho přiřadit do jiné l-hodnoty (např. proměnné).
Také si všimněme, že lze použít závorky () k seskupování výrazů a úpravě jejich priorit (víme, že násobení má přednost před sčítáním), tato základní asociativita funguje stejně jako v matematice, pokud si nejsme jisti, nemusíme experimentovat a prostě se pojistíme závorkou.
</P>

</DIV>
<!-- SECTION "Příklad" [32216-32829] -->
<H2><A name="prehled_operatoru" id="prehled_operatoru">Přehled operátorů</A></H2>
<DIV class="level2">

<P>
Zde naleznete seznam různých operátorů. Některé z nich budeme používat a vysvětlíme si je, ale většinu z nich zatím potřebovat nebudeme, ale k tomuto seznamu se určitě budete potřebovat vracet.

</P>
<PRE class="code">+	sčítání
-	odčítání
*	násobení
/	dělení</PRE>
<PRE class="code">%	dělení modulo (zbytek po dělení)</PRE>
<PRE class="code">++, --  inkrementace resp. dekrementace hodnoty, prefixový i postfixový zápis
= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= |= ^= 	jednoduché přiřazení a přiřazení s výpočtem</PRE>
<PRE class="code">&lt; 	menší než
&gt; 	větší než
&lt;= 	menší nebo rovno
&gt;= 	větší nebo rovno
== 	rovnost
!= 	nerovnost</PRE>
<PRE class="code">&amp;&amp; 	logický součin (and)
|| 	logický součet (or)</PRE>
<PRE class="code">!  	logická negace
~ 	bitová negace</PRE>
<PRE class="code">&lt;&lt;, &gt;&gt;  bitový posun vlevo resp. vpravo
&amp; 	bitový součin (and)
| 	bitový součet (or)
^ 	bitový vylučovací (exkluzivní) součet (xor)</PRE>
<PRE class="code">?:  	podmíněné vyhodnocení  	zprava doleva</PRE>
<PRE class="code">. 	tečka, přímý přístup ke členu struktury
-&gt; 	nepřímý přístup ke členu struktury
, 	čárka, oddělení výrazů</PRE>
<PRE class="code">sizeof	získání velikosti objektu v bytech
(typ)  	přetypování na typ uvedený v závorkách</PRE>
<PRE class="code">&amp;  	reference (získání adresy objektu)
* 	dereference (získání objektu dle adresy)</PRE>

</DIV>
<!-- SECTION "Přehled operátorů" [32830-34104] -->
<H2><A name="porovnavani" id="porovnavani">Porovnávání</A></H2>
<DIV class="level2">

<P>
V kapitole, kde budeme probírat podmínky a cykly určitě využijeme porovnávací operátory (&lt;,&gt;,⇐,&gt;=,==,!<IMG src="./jazyk_c compilation_files/icon_smile2.gif" class="middle" alt="=)">, logickou negaci (!) a logický součin a součet (&amp;&amp;,||).
Pokud jde o porovnávací operátory, tak vždy vrací hodnotu true (1 nebo jiná nenulová hodnota), nebo  false (0), tj. pravda/nepravda.
Logický součin (&amp;&amp;) vrací true pouze pokud jsou obě hodnoty true. Pokud je první hodnota false, tak se druhá nevyhodnocuje (zjednodusene vyhodnocovani).
Logický součet (||) vrací true pokud je alespoň jedna z hodnot true. Pokud je první hodnota true, tak se druhá nevyhodnocuje (zjednodusene vyhodnocovani).
Logická negace vrací opak (!1 je 0, !0 je 1).
</P>

</DIV>
<!-- SECTION "Porovnávání" [34105-34814] -->
<H2><A name="priklady" id="priklady">Příklady</A></H2>
<DIV class="level2">
<PRE class="code c"><SPAN class="kw4">int</SPAN> a <SPAN class="sy0">=</SPAN> 2<SPAN class="sy0">,</SPAN> b <SPAN class="sy0">=</SPAN> 3<SPAN class="sy0">,</SPAN> x <SPAN class="sy0">=</SPAN> 4<SPAN class="sy0">,</SPAN> y <SPAN class="sy0">=</SPAN> <SPAN class="nu0">2</SPAN><SPAN class="sy0">;</SPAN>
b <SPAN class="sy0">=</SPAN> <SPAN class="sy0">!</SPAN><SPAN class="br0">(</SPAN>b <SPAN class="sy0">==</SPAN> a<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//b bude true</SPAN>
b <SPAN class="sy0">=</SPAN> <SPAN class="br0">(</SPAN>b <SPAN class="sy0">!=</SPAN> a<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//b bude true (jde o prakticky jiny zapis stejneho vypoctu)</SPAN>
b <SPAN class="sy0">=</SPAN> <SPAN class="br0">(</SPAN>a <SPAN class="sy0">=</SPAN> 2<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//casta chyba - nedojde k porovnani, ale prirazeni 2 do a a nasledne do b</SPAN>
x <SPAN class="sy0">=</SPAN> <SPAN class="br0">(</SPAN>x <SPAN class="sy0">&lt;=</SPAN> y<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//x bude false</SPAN>
y <SPAN class="sy0">=</SPAN> <SPAN class="sy0">!</SPAN><SPAN class="br0">(</SPAN><SPAN class="br0">(</SPAN>1 <SPAN class="sy0">&lt;=</SPAN> 2<SPAN class="br0">)</SPAN><SPAN class="sy0">||</SPAN><SPAN class="br0">(</SPAN>b <SPAN class="sy0">=</SPAN> 7<SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//y bude false, prirazeni 7 do b neprobehne (pouzito zjednodusene vyhodnocovani)</SPAN>
y <SPAN class="sy0">=</SPAN> <SPAN class="nu0">128</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//y bude true</SPAN>
y <SPAN class="sy0">=</SPAN> <SPAN class="nu0">0</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//y bude false</SPAN>
y <SPAN class="sy0">=</SPAN> <SPAN class="sy0">!</SPAN>y<SPAN class="sy0">;</SPAN> <SPAN class="co1">//y bude true</SPAN></PRE>

</DIV>
<!-- SECTION "Příklady" [34815-35280] -->
<H2><A name="inkrementace_dekrementace" id="inkrementace_dekrementace">Inkrementace, dekrementace,...</A></H2>
<DIV class="level2">

<P>
Hodnotu proměnné můžeme změnit i jiným způsobem, než je přiřazení:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> a <SPAN class="sy0">=</SPAN> 31<SPAN class="sy0">,</SPAN> b<SPAN class="sy0">;</SPAN>
a<SPAN class="sy0">++;</SPAN> <SPAN class="co1">//a bude zvětšena o 1 (jiný zápis: a = a+1; )</SPAN>
a <SPAN class="sy0">*=</SPAN> <SPAN class="nu0">2</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//a bude vynásobeno 2 (jiný zápis: a = a*2; )</SPAN>
b <SPAN class="sy0">=</SPAN> a<SPAN class="sy0">++;</SPAN> <SPAN class="co1">//a bude přiřazeno do b a následně zvětšeno o 1</SPAN>
b <SPAN class="sy0">=</SPAN> <SPAN class="sy0">--</SPAN>a<SPAN class="sy0">;</SPAN> <SPAN class="co1">//a bude zmenšeno o 1 a nasledne prirazeno do b</SPAN></PRE>

</DIV>
<!-- SECTION "Inkrementace, dekrementace,..." [35281-35668] -->
<H2><A name="operator_sizeof" id="operator_sizeof">Operátor sizeof()</A></H2>
<DIV class="level2">

<P>
sizeof je makro preprocesoru, které nám vrátí velikost daného datového typu (viz. kapitola jednoduché datové typy) v bytech. Víme, že například celé číslo (int) zabírá v paměti většinou 2 byty, výraz sizeof(int) nám tedy vrátí u většiny kompilátorů číslo 2.
</P>

</DIV>
<!-- SECTION "Operátor sizeof()" [35669-35989] -->
<H2><A name="samostatne_cviceni2" id="samostatne_cviceni2">Samostatné cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Vymyslete přiřazení co nejsložitějšího výrazu, jehož výsledkem bude hodnota false.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Jakou hodnotu bude mít následující výraz:</DIV>
<UL>
<LI class="level2"><DIV class="li"> <PRE class="code c"><SPAN class="br0">(</SPAN><SPAN class="br0">(</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN><SPAN class="br0">(</SPAN>1 <SPAN class="sy0">&gt;</SPAN> 2 <SPAN class="sy0">||</SPAN> <SPAN class="nu0">2</SPAN> <SPAN class="sy0">&gt;</SPAN> <SPAN class="nu0">1</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="sy0">*</SPAN> <SPAN class="nu0">2</SPAN> <SPAN class="sy0">+</SPAN> <SPAN class="nu0">4</SPAN><SPAN class="br0">)</SPAN> <SPAN class="sy0">/</SPAN> <SPAN class="nu0">2</SPAN><SPAN class="br0">)</SPAN> <SPAN class="sy0">==</SPAN> <SPAN class="nu0">7</SPAN></PRE>
</DIV>
</LI>
</UL>
</LI>
</UL>

</DIV>
<!-- SECTION "Samostatné cvičení" [35990-36234] -->
<H1><A name="standartni_vstup_a_vystup" id="standartni_vstup_a_vystup">Standartní vstup a výstup</A></H1>
<DIV class="level1">

</DIV>
<!-- SECTION "Standartní vstup a výstup" [36235-36277] -->
<H2><A name="radkovy_vystup" id="radkovy_vystup">Řádkový výstup</A></H2>
<DIV class="level2">

<P>
Již jsme se seznámili s použitím funkce printf(), další užitečnou funkcí je putchar(), která vypíše jeden znak/byte.
</P>

</DIV>
<!-- SECTION "Řádkový výstup" [36278-36438] -->
<H3><A name="vstup" id="vstup">Vstup</A></H3>
<DIV class="level3">

<P>
Samozřejmě budeme potřebovat také odezvu ze strany uživatele, k tomu nám budou sloužit funkce scanf(), která je opakem printf() a getchar(), která je opakem putchar().
</P>

<P>
Funkce getchar() nám vrací <ACRONYM title="American Standard Code for Information Interchange">ASCII</ACRONYM> hodnotu jediného načteného znaku.
</P>

<P>
Funkce scanf() nám oproti tomu zapíše získaná data na danou adresu v paměti, to nebudeme hlouběji rozebírat, důležité ale je, že před identifikátor proměnné musíme napsat operátor ampersand (“&amp;“). Pokud tedy budeme například chtít načíst z klávesnice desítkové číslo, použijeme tento zápis:
</P>
<PRE class="code c">  <SPAN class="kw4">int</SPAN> a<SPAN class="sy0">;</SPAN>
  scanf<SPAN class="br0">(</SPAN><SPAN class="st0">"%d"</SPAN><SPAN class="sy0">,</SPAN> <SPAN class="sy0">&amp;</SPAN>a<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>

</DIV>
<!-- SECTION "Vstup" [36439-37073] -->
<H3><A name="prevod_retezce_na_cislo" id="prevod_retezce_na_cislo">Převod řetězce na číslo</A></H3>
<DIV class="level3">

<P>
Často potřebujeme, aby nám uživatel zadal číslo, z terminálu můžeme číst ale pouze znaky (případně řetězce). Naštěstí pro nás existují v Ansi C funkce, které nám dovolí uskutečnit tento převod, jsou to tyto:

</P>
<UL>
<LI class="level1"><DIV class="li"> atoi() - ascii to int</DIV>
</LI>
<LI class="level1"><DIV class="li"> atol() - ascii to long</DIV>
</LI>
<LI class="level1"><DIV class="li"> atof() - ascii to float</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Převod řetězce na číslo" [37074-37430] -->
<H3><A name="souhrnne_priklady" id="souhrnne_priklady">Souhrnné příklady</A></H3>
<DIV class="level3">
<PRE class="code c">  <SPAN class="kw4">char</SPAN> text<SPAN class="br0">[</SPAN><SPAN class="br0">]</SPAN> <SPAN class="sy0">=</SPAN> <SPAN class="st0">"Toto je nějaký text"</SPAN><SPAN class="sy0">;</SPAN>
  <SPAN class="kw4">int</SPAN> cislo <SPAN class="sy0">=</SPAN> <SPAN class="nu0">5</SPAN><SPAN class="sy0">;</SPAN>
  <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Toto je text: %s a tohle cislo: %d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> text<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Vypíše: Toto je text: Toto je nějaký text a tohle cislo: 5(a odřádkuje)</SPAN>
&nbsp;
  <SPAN class="kw4">char</SPAN> ascii_cislo<SPAN class="br0">[</SPAN><SPAN class="br0">]</SPAN> <SPAN class="sy0">=</SPAN> <SPAN class="st0">"64"</SPAN><SPAN class="sy0">;</SPAN>
  cislo <SPAN class="sy0">=</SPAN> atoi<SPAN class="br0">(</SPAN>ascii_cislo<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Priradi do promene cislo cislo urcene retezcem ascii_cislo[], tj.: 64.</SPAN>
&nbsp;
  <SPAN class="kw4">char</SPAN> vstup<SPAN class="br0">[</SPAN>1024<SPAN class="br0">]</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Toto není příliš optimální řešení, protože se v něm skrývá bezpečnostní hrozba, nebo možnost kolapsu našeho programu, pokud uživatel zadá více jak 1024 znaků... My se tímto problémem ale zatím zabývat nebudeme, ovšem nutno poznamenat, že správné řešení by bylo úplně jiné.</SPAN>
  <SPAN class="kw4">int</SPAN> vstup_cislo<SPAN class="sy0">;</SPAN>
  scanf<SPAN class="br0">(</SPAN><SPAN class="st0">"%s"</SPAN><SPAN class="sy0">,</SPAN> <SPAN class="sy0">&amp;</SPAN>vstup<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
  scanf<SPAN class="br0">(</SPAN><SPAN class="st0">"%d"</SPAN><SPAN class="sy0">,</SPAN> <SPAN class="sy0">&amp;</SPAN>vstup_cislo<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>

</DIV>
<!-- SECTION "Souhrnné příklady" [37431-38208] -->
<H3><A name="dalsi_prevody" id="dalsi_prevody">Další převody</A></H3>
<DIV class="level3">

<P>
Další velice používanou funkcí pro převody (např. čísla na řetězec) je sprintf().
Tato funkce pracuje obdobně, jako printf() (kterou doufám již všichni známe), s tím rozdílem, že sprintf() přijímá ještě první argument, kterým je identifikátor řetězce, do kterého bude po zformátování výsledný řetězec uložen (printf() by ho jen vypsalo).
</P>

</DIV>
<!-- SECTION "Další převody" [38209-38613] -->
<H3><A name="reseny_priklad" id="reseny_priklad">Řešený příklad</A></H3>
<DIV class="level3">
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=8" title="St&aacute;hnout snippet" class="mediafile mf_c">calc.c</A></DT>
<DD><PRE class="code file c"><SPAN class="coMULTI">/* calc.c
 * Napište program, který načte z řádky dvě čísla, sečte je a výsledek vypíše formou rovnice.
 * K získání prvního celého čísla použijte přímo scanf(), druhé převeďte z řetězce získaného ze scanf() pomocí atoi().
 * Program zkompilujte a otestujte.
 */</SPAN>
&nbsp;
<SPAN class="co2">#include &lt;stdio.h&gt;</SPAN>
<SPAN class="co2">#include &lt;stdlib.h&gt;</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw4">char</SPAN> a<SPAN class="br0">[</SPAN>10<SPAN class="br0">]</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw4">int</SPAN> x<SPAN class="sy0">,</SPAN> y<SPAN class="sy0">;</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Prvni scitanec: "</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	scanf<SPAN class="br0">(</SPAN><SPAN class="st0">"%d"</SPAN><SPAN class="sy0">,</SPAN> <SPAN class="sy0">&amp;</SPAN>x<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Prvni cislo nacteme rovnou jako dekadickou hodnotu</SPAN>
&nbsp;
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Druhy scitanec: "</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	scanf<SPAN class="br0">(</SPAN><SPAN class="st0">"%s"</SPAN><SPAN class="sy0">,</SPAN> <SPAN class="sy0">&amp;</SPAN>a<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Do retezce a ulozime ascii zapis cisla (pismenka) z klavesnice</SPAN>
	y <SPAN class="sy0">=</SPAN> atoi<SPAN class="br0">(</SPAN>a<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Do integeru y ulozime cislo ziskane z retezce a</SPAN>
&nbsp;
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Vysledek: %d+%d = %d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> x<SPAN class="sy0">,</SPAN> y<SPAN class="sy0">,</SPAN> <SPAN class="br0">(</SPAN>x<SPAN class="sy0">+</SPAN>y<SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Vypiseme vysledek</SPAN>
<SPAN class="br0">}</SPAN></PRE>
</DD></DL>

<P>
Například takto vypadá program za běhu:
</P>
<PRE class="code">harvie@harvie-ntb:~/Desktop/skripta/c$ gcc calc.c -o calc -std=c99 &amp;&amp; chmod +x calc #kompilace
harvie@harvie-ntb:~/Desktop/skripta/c$ ./calc #spusteni
Prvni scitanec: 2
Druhy scitanec: 3
Vysledek: 2+3 = 5
harvie@harvie-ntb:~/Desktop/skripta/c$</PRE>

</DIV>
<!-- SECTION "Řešený příklad" [38614-39689] -->
<H3><A name="presmerovani_vstupu_a_vystupu" id="presmerovani_vstupu_a_vystupu">Přesměrování vstupu a výstupu</A></H3>
<DIV class="level3">

<P>
Zjistěte si, jakým způsobem umí váš operační systém přesměrovávat vstup a výstup do souborů a ze souborů, tak aby se výstup programu nevypsal na obrazovaku, ale do souboru, nebo naopak se vstup načetl ze souboru, nebo byl výstup přesměrován na vstup jiného programu. (většinou k tomu slouží operátory příkazového řádku &gt;,»,&lt;,|). 
</P>

<P>
Kromě použití operátorů příkazové řádky tohoto také můžeme docílit pomocí funkce freopen() aplikované na handly stdin, stdout, nebo stderr, to ale pro nás není zatím nutné umět.
</P>

</DIV>
<!-- SECTION "Přesměrování vstupu a výstupu" [39690-40299] -->
<H3><A name="samostatna_cviceni" id="samostatna_cviceni">Samostatná cvičení</A></H3>
<DIV class="level3">
<UL>
<LI class="level1"><DIV class="li"> Upravte program tak, aby fungoval nad desetinými čísly (float)</DIV>
</LI>
<LI class="level1"><DIV class="li"> Předchozí program upravte tak, aby po spuštění vypsal 3 očíslované možnosti a podle zadaného čísla buď sčítal, odčítal, nebo násobil.</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Samostatná cvičení" [40300-40558] -->
<H1><A name="podminky_a_cykly" id="podminky_a_cykly">Podmínky a cykly</A></H1>
<DIV class="level1">

<P>
Tyto dvě důležité věci jsou častou součástí většiny programů.
</P>

</DIV>
<!-- SECTION "Podmínky a cykly" [40559-40667] -->
<H2><A name="podminka" id="podminka">Podmínka</A></H2>
<DIV class="level2">

<P>
Podmínka je operátor, který nám umožní vykonat nějaký kód pouze pokud je splněna nějaká podmínka. Podmínka se vyhodnocuje tak, že se vypočítá hodnota výrazu předaného podmínce a pokud tato hodnota odpovídá logické pravdě (to většinou znamená nenulové číslo), vykoná se daný příkaz.
</P>

<P>
Jednoduchá podmínka může vypadat například takto:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> a <SPAN class="sy0">=</SPAN> 1<SPAN class="sy0">,</SPAN> b <SPAN class="sy0">=</SPAN> <SPAN class="nu0">2</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>a<SPAN class="sy0">&lt;</SPAN>b<SPAN class="br0">)</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"a je mensi nez b"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>

<P>
Jaké operátory máme a jak se vyhodnocují jsme se již dozvěděli z kapitoly operátory, na druhou stranu to nemusí být na první pohled jasné, proto ještě v rychlosti shrnu alespoň srovnávací (komparační) operátory:

</P>
<PRE class="code">== - je rovno
!= - není rovno
&gt;  - větší než
&lt;  - menší než
&gt;= - větší nebo rovno
&lt;= - menší nebo rovno
!  - logická negace
&amp;&amp; - logické AND (A)
|| - logické OR (NEBO)</PRE>

<P>

Pokud tyto operátory použijeme na dvě čísla (operandy), výslednou hodnotou bude vždy logická hodnota (pravda/nepravda - true/false - 1/0), u většiny kompilátorů je to 0 nebo 1. Pokud tedy vyhodnocujeme podmínku (např. pomocí if()), pokaždé, když ji předáme nenulovou hodnotu, je proveden následující příkaz. Např.:
</P>
<PRE class="code c"><SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>1<SPAN class="br0">)</SPAN> <SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>255<SPAN class="br0">)</SPAN> <SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN>0<SPAN class="br0">)</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"tento prikaz bude proveden vzdy<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN>1<SPAN class="br0">)</SPAN> <SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>0<SPAN class="br0">)</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"tento prikaz nebude proveden nikdy<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>

<P>
S if souvisí ještě jeden operátor a tím je else, tím můžeme určit co se stane, když podmínka splněna nebude.
</P>
<PRE class="code c"><SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>a<SPAN class="sy0">&gt;</SPAN>b<SPAN class="br0">)</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"a je mensi nez b<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="kw1">else</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"a je vetsi nez b<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>

</DIV>
<!-- SECTION "Podmínka" [40668-42273] -->
<H2><A name="slozeny_prikaz_blok_kodu" id="slozeny_prikaz_blok_kodu">Složený příkaz (Blok kódu)</A></H2>
<DIV class="level2">

<P>
Pokud několik příkazů uzavřeme do složených závorek, začnou se vůči kódu mimo ně chovat jako jeden příkaz. V podmínkách a cyklech můžeme tedy vykonat více příkazů tam, kde bychom mohli normálně vykonat pouze jeden. např. následující kód vypíše 3x „Nejaky text\n“.
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> podminka <SPAN class="sy0">=</SPAN> <SPAN class="nu0">1</SPAN><SPAN class="sy0">;</SPAN>
&nbsp;
<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>podminka<SPAN class="br0">)</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Nejaky text<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>podminka<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Nejaky "</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"text<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="br0">}</SPAN>
<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>podminka<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Nejaky "</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"text<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="br0">}</SPAN></PRE>

<P>
Následující kód pak zmenší hodnotu většího ze dvou čísel.
</P>
<PRE class="code c"><SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>a<SPAN class="sy0">&gt;</SPAN>b<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	a<SPAN class="sy0">--;</SPAN>
<SPAN class="br0">}</SPAN> <SPAN class="kw1">else</SPAN> <SPAN class="br0">{</SPAN>
	b<SPAN class="sy0">--;</SPAN>
<SPAN class="br0">}</SPAN></PRE>

</DIV>
<!-- SECTION "Složený příkaz (Blok kódu)" [42274-42921] -->
<H2><A name="cyklus_while" id="cyklus_while">Cyklus while</A></H2>
<DIV class="level2">

<P>
Jde o základní cyklus, jediné, čím se liší od podmínky je to, že se příkaz neustále opakuje, dokud je podmínka splněna.
Příklady:
</P>
<PRE class="code c"><SPAN class="kw1">while</SPAN><SPAN class="br0">(</SPAN>1<SPAN class="br0">)</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"#"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Budeme do nekonečna vypisovat znak '#'</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> i <SPAN class="sy0">=</SPAN> <SPAN class="nu0">30</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="kw1">while</SPAN><SPAN class="br0">(</SPAN>i<SPAN class="sy0">&gt;</SPAN><SPAN class="nu0">10</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> <SPAN class="co1">//Budeme zmensovat i, dokud bude vetsi nez 10</SPAN>
	i<SPAN class="sy0">--;</SPAN>
<SPAN class="br0">}</SPAN></PRE>

</DIV>
<!-- SECTION "Cyklus while" [42922-43256] -->
<H2><A name="cyklus_for" id="cyklus_for">Cyklus for</A></H2>
<DIV class="level2">

<P>
Cyklus for je podobný cyklu while, akorát s tím rozdílem, že kromě podmínky obsahuje také příkazy, které se spustí před začátkem cyklu a pak při každé iteraci (opakování).
</P>

<P>
Následující while cyklus
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> i <SPAN class="sy0">=</SPAN> <SPAN class="nu0">30</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="kw1">while</SPAN><SPAN class="br0">(</SPAN>i<SPAN class="sy0">&gt;</SPAN>10<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	i<SPAN class="sy0">--;</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"%d"</SPAN><SPAN class="sy0">,</SPAN> i<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>

<P>

tedy můžeme zapsat pomocí for-u i takto:

</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> i<SPAN class="sy0">;</SPAN>
<SPAN class="kw1">for</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> i<SPAN class="sy0">=</SPAN><SPAN class="nu0">30</SPAN><SPAN class="sy0">;</SPAN>i<SPAN class="sy0">&gt;</SPAN><SPAN class="nu0">10</SPAN><SPAN class="sy0">;</SPAN>i<SPAN class="sy0">--</SPAN><SPAN class="br0">)</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"%d"</SPAN><SPAN class="sy0">,</SPAN> i<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>

<P>
Což je mnohem přehlednější.
</P>

</DIV>
<!-- SECTION "Cyklus for" [43257-43713] -->
<H2><A name="vnorene_zahnizdene_cykly" id="vnorene_zahnizdene_cykly">Vnořené (zahnízděné) cykly</A></H2>
<DIV class="level2">

<P>
Dobré je si také uvědomit, že můžeme mít například dva cykly v sobě.
</P>

</DIV>
<!-- SECTION "Vnořené (zahnízděné) cykly" [43714-43837] -->
<H2><A name="reseny_priklad1" id="reseny_priklad1">Řešený příklad</A></H2>
<DIV class="level2">

<P>
Napište program, který vypíše za sebe čísla od 0 do 10 a zpět oddělené čárkami.
</P>
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=17" title="St&aacute;hnout snippet" class="mediafile mf_c">loops.c</A></DT>
<DD><PRE class="code file c"><SPAN class="co2">#include &lt;stdio.h&gt;</SPAN>
<SPAN class="co2">#include &lt;stdlib.h&gt;</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw4">int</SPAN> x<SPAN class="sy0">=</SPAN>1<SPAN class="sy0">,</SPAN> a<SPAN class="sy0">=</SPAN><SPAN class="nu0">0</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw1">for</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> i<SPAN class="sy0">=</SPAN><SPAN class="nu0">0</SPAN><SPAN class="sy0">;</SPAN>i<SPAN class="sy0">&lt;=</SPAN><SPAN class="nu0">20</SPAN><SPAN class="sy0">;</SPAN>i<SPAN class="sy0">++</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">{</SPAN>
		<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"%d"</SPAN><SPAN class="sy0">,</SPAN> a<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
		<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>i<SPAN class="sy0">&lt;</SPAN>20<SPAN class="br0">)</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">","</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
		<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>a<SPAN class="sy0">&gt;=</SPAN>10<SPAN class="br0">)</SPAN> x<SPAN class="sy0">=</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">-</SPAN>1<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
		a<SPAN class="sy0">+=</SPAN>x<SPAN class="sy0">;</SPAN>
	<SPAN class="br0">}</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN>
&nbsp;
<SPAN class="co1">//EOF</SPAN></PRE>
</DD></DL>

<P>
Výstup:
</P>
<PRE class="code">harvie@harvie-ntb:~/Desktop/skripta/c$ ./loops
0,1,2,3,4,5,6,7,8,9,10,9,8,7,6,5,4,3,2,1,0</PRE>

</DIV>
<!-- SECTION "Řešený příklad" [43838-44282] -->
<H2><A name="samostatna_cviceni1" id="samostatna_cviceni1">Samostatná cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Upravte předchozí program tak, aby nepoužíval více než jeden cyklus</DIV>
</LI>
<LI class="level1"><DIV class="li"> Napište program, který 10x pod sebe vypíše číslice od 0 do 9.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Upravte předchozí program tak, aby vykreslil šachovnici (8×8) z 0 a 1.</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Samostatná cvičení" [44283-44544] -->
<H1><A name="pole" id="pole">Pole</A></H1>
<DIV class="level1">

<P>
Pole je datový typ skládající se z určitého počtu jiných datových typů.
Zatím jsme se s poli setkali jen jako s řetězci (řetězec je pole jednotlivých znaků, pole končí znakem s <ACRONYM title="American Standard Code for Information Interchange">ASCII</ACRONYM> hodnotou \x00).
</P>

<P>
Nejlepší bude, pokud si to vysvětlíme na jednoduchém příkladu. Například budeme potřebovat uložit 10 čísel int, které budou všechny sloužit k podobnému účelu, ale je možné, že se jejich počet bude v budoucnosti měnit, nebo jsme líní pro je jednotlivě deklarovat (a byli bysme hloupí, kdybychom to tak dělali).
</P>

<P>
Použijeme tedy např. tuto deklaraci:
</P>
<PRE class="code">int cisla[10];</PRE>

<P>

Tím jsme poprosili systém o 10*sizeof(int) bytů (neboli paměť potřebnou pro uložení 10 integerů, typicky to bude 20B).
</P>

<P>
Nyní můžeme s čísli jednoduše pracovat, musíme si však pamatovat, že ačkoli jsme nadeklarovali 10 integerů, k prvnímu přistupujeme pomocí [0] a k desátému pomocí [9], proč tomu tak je si vysvětlíme za chvilku.
</P>

</DIV>
<!-- SECTION "Pole" [44545-45539] -->
<H2><A name="priklad1" id="priklad1">Příklad</A></H2>
<DIV class="level2">
<PRE class="code c"><SPAN class="kw4">int</SPAN> cisla<SPAN class="br0">[</SPAN>10<SPAN class="br0">]</SPAN><SPAN class="sy0">,</SPAN> a <SPAN class="sy0">=</SPAN> <SPAN class="nu0">2</SPAN><SPAN class="sy0">;</SPAN>
cisla<SPAN class="br0">[</SPAN>0<SPAN class="br0">]</SPAN> <SPAN class="sy0">=</SPAN> <SPAN class="nu0">1</SPAN><SPAN class="sy0">;</SPAN>
cisla<SPAN class="br0">[</SPAN>1<SPAN class="br0">]</SPAN> <SPAN class="sy0">=</SPAN> <SPAN class="nu0">2</SPAN><SPAN class="sy0">;</SPAN>
cisla<SPAN class="br0">[</SPAN>a<SPAN class="br0">]</SPAN> <SPAN class="sy0">=</SPAN> cisla<SPAN class="br0">[</SPAN>0<SPAN class="br0">]</SPAN><SPAN class="sy0">*</SPAN>cisla<SPAN class="br0">[</SPAN>1<SPAN class="br0">]</SPAN><SPAN class="sy0">+</SPAN>cisla<SPAN class="br0">[</SPAN>2<SPAN class="br0">]</SPAN><SPAN class="sy0">;</SPAN>
cisla<SPAN class="br0">[</SPAN>2<SPAN class="br0">]</SPAN><SPAN class="sy0">++;</SPAN>
<SPAN class="co1">//promenna cisla[2] drzi nyni hodnotu 5</SPAN>
&nbsp;
cisla<SPAN class="br0">[</SPAN>10<SPAN class="br0">]</SPAN> <SPAN class="sy0">=</SPAN> <SPAN class="nu0">18</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Zde by zase pravděpodobně došlo k pádu programu, protože se pokoušíme přistupovat k neexistující 11. položce pole.</SPAN></PRE>

</DIV>
<!-- SECTION "Příklad" [45540-45865] -->
<H2><A name="ulozeni_pole_v_pameti" id="ulozeni_pole_v_pameti">Uložení pole v paměti</A></H2>
<DIV class="level2">

<P>
držme se naší deklarace z předchozího příkladu, tedy:
</P>
<PRE class="code">int cisla[10];</PRE>

<P>
V tom případě jsme si říkali, že bude v paměti alokováno 10*sizeof(int) bytů, to bude vypadat následovně:

</P>
<PRE class="code"> __ __ __ __ __ __ __ __ __ __ 
|00|00|00|00|00|00|00|00|00|00|
 -- -- -- -- -- -- -- -- -- --
^                          ^
|_ Toto je adresa &amp;cisla   |_  Toto je adresa &amp;cisla+9*sizeof(int) (neboli cisla[9])
   (neboli cisla[0])</PRE>

<P>

Pokud si tedy zkusíme vytisknout printf(“%d\n“, &amp;cisla);, získáme adresu v paměti (to dělá operátor &amp;), na které je naše pole uložené, touto adresou je obyčejné číslo, je ale zvykem zapisovat ho šestnáctkově, toto je pro nás ale zatím dostačující.
</P>

<P>
Tím, že použijeme zápis cisla[0] dojde k tomu, že získáme přístup k sizeof(int) bytům na adrese &amp;cisla, tedy k prvnímu integeru, když chceme přistupovat k druhému integeru v poli použijeme cisla[1], protože tím se dostáváme z adresy &amp;cisla o jeden int dále (tedy: &amp;cisla+1*sizeof(int)), je tedy zřejmé, že pokud se pokusíme pracovat s cisla[10], octneme se již v části paměti, která nepatří našemu programu a náš program bude ukončen, protože v jiném případě by náš program mohl ovlivňovat práci jiného programu.
</P>

</DIV>
<!-- SECTION "Uložení pole v paměti" [45866-47173] -->
<H2><A name="zjisteni_velikosti_pole" id="zjisteni_velikosti_pole">Zjištění velikosti pole</A></H2>
<DIV class="level2">

<P>
Je možné, že neznáme velikost pole, a potřebujeme ho zpracovat (např. v cyklu), k tomu opět použijeme operátor sizeof(). V následujícím příkladu si také můžete všimnout, že při deklaraci pole můžeme jeho velikost určit jinou celočíselnou proměnnou (to je možné až v novějších verzích jazyka C).
Následující kus kódu ukazuje, jak zjistit a vypsat velikost pole.
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> i <SPAN class="sy0">=</SPAN> <SPAN class="nu0">30</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="kw4">int</SPAN> cisla<SPAN class="br0">[</SPAN>i<SPAN class="br0">]</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="co1">//Nejaky jiny kod</SPAN>
<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Pocet cisel: %d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> <SPAN class="kw4">sizeof</SPAN><SPAN class="br0">(</SPAN>cisla<SPAN class="br0">)</SPAN><SPAN class="sy0">/</SPAN><SPAN class="kw4">sizeof</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>

<P>
Příkaz sizeof(cisla) nám vrátí počet bytů, které pole skutečně zabírá v paměti, to může být různé. nás ale zajímá kolik prvků (int) pole má a s kolika můžeme ve skutečnosti pracovat. K tomu musíme ještě toto číslo vydělit hodnotou sizeof(int) (nebo sizeof(jiny_typ_naseho_pole)), ta totiž určuje, kolik každý prvek pole zabírá v paměti.
</P>

<P>
Když si to shrneme: Víme, kolik místa zabírá pole v RAMce a víme, kolik má zabírat jeden jediný prvek, jednoduše tedy vydělíme (vrátíme se ve vzpomínkách do 2. třídy ZŠ ;) a máme požadované číslo, pokud nás ovšem zajímá nejvyšší „offset“ (to číslo v hranatých závorkách), jaké můžeme použít, nesmíme ještě zapomenout odečíst 1.
</P>

</DIV>
<!-- SECTION "Zjištění velikosti pole" [47174-48481] -->
<H2><A name="n-rozmerna_pole" id="n-rozmerna_pole">N-rozměrná pole</A></H2>
<DIV class="level2">

<P>
Můžeme také vytvářet mnohorozměrná pole (např.: dvou-rozměrná, tří-rozměrná, sto-rozměrná, n-rozměrná), takové mnohorozměrné pole je laicky řečeno pole polí, nebo pole polí polí polí polí, typickým příkladem je pole řetězců.
</P>

<P>
Deklarace takového pole může vypadat takto:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> a<SPAN class="br0">[</SPAN>3<SPAN class="br0">]</SPAN><SPAN class="br0">[</SPAN>40<SPAN class="br0">]</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//a je pole 40ti polí o 3 integerech</SPAN>
<SPAN class="co1">//Podobná pole si většinou představujeme jako 3x40 čtverečků (40 je výška)</SPAN>
<SPAN class="kw4">char</SPAN> c<SPAN class="br0">[</SPAN>4<SPAN class="br0">]</SPAN><SPAN class="br0">[</SPAN>6<SPAN class="br0">]</SPAN><SPAN class="br0">[</SPAN>8<SPAN class="br0">]</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="co1">//Takové pole si pro změnu můžeme vizualizovat jako 8mi patrový kvádr, přičemž každé patro se zkládá z 4x6 kostiček (každá kostička drží nějaký znak).</SPAN></PRE>

<P>
U složitějších polí si můžeme představit například několik takových kvádříků uspořádaných do několika polic v několika skříních v několika řadách,…
Prostě jakkoli.
</P>

<P>

Pokud máme například pole int pole[2][3], pak pole[0] je pole 3 integerů jako např. int druhe[3].
</P>

<P>
Ostatní práce s poli je naprosto analogická k polím jednorozměrným.
</P>

</DIV>
<!-- SECTION "N-rozměrná pole" [48482-49538] -->
<H2><A name="reseny_priklad_-_zpracovani_pole_v_cyklu" id="reseny_priklad_-_zpracovani_pole_v_cyklu">Řešený příklad - zpracování pole v cyklu</A></H2>
<DIV class="level2">

<P>
Toto je velmi často používaná věc! Více se dozvíte v kapitole „podmínky a cykly“, tady jen uvádím jednoduchý příklad.
Můžeme si zde všimnout dvou totožných cyklů, přičemž jeden je while() a druhý for().
</P>
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=21" title="St&aacute;hnout snippet" class="mediafile mf_c">arrays.c</A></DT>
<DD><PRE class="code file c"><SPAN class="coMULTI">/* arrays.c
 * Napiste program, ktery naplni pole integeru nahodnymy cisly a potom je vypise.
 * Pouzijte cykly for i while
 */</SPAN>
&nbsp;
<SPAN class="co2">#include &lt;stdio.h&gt;</SPAN>
<SPAN class="co2">#include &lt;stdlib.h&gt;</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw4">int</SPAN> i<SPAN class="sy0">,</SPAN> cisla<SPAN class="br0">[</SPAN>10<SPAN class="br0">]</SPAN><SPAN class="sy0">;</SPAN>
&nbsp;
	i<SPAN class="sy0">=</SPAN><SPAN class="nu0">0</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw1">while</SPAN><SPAN class="br0">(</SPAN>i<SPAN class="sy0">&lt;</SPAN>sizeof<SPAN class="br0">(</SPAN>cisla<SPAN class="br0">)</SPAN><SPAN class="sy0">/</SPAN><SPAN class="kw4">sizeof</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
		cisla<SPAN class="br0">[</SPAN>i<SPAN class="br0">]</SPAN> <SPAN class="sy0">=</SPAN> rand<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//K generovani nahodnych cisel slouzi funkce rand()</SPAN>
		i<SPAN class="sy0">++;</SPAN>
	<SPAN class="br0">}</SPAN>
&nbsp;
	<SPAN class="kw1">for</SPAN><SPAN class="br0">(</SPAN>i<SPAN class="sy0">=</SPAN><SPAN class="nu0">0</SPAN><SPAN class="sy0">;</SPAN>i<SPAN class="sy0">&lt;</SPAN>sizeof<SPAN class="br0">(</SPAN>cisla<SPAN class="br0">)</SPAN><SPAN class="sy0">/</SPAN><SPAN class="kw4">sizeof</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>i<SPAN class="sy0">++</SPAN><SPAN class="br0">)</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"%d. cislo je: %d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> i<SPAN class="sy0">,</SPAN> cisla<SPAN class="br0">[</SPAN>i<SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN>
&nbsp;
<SPAN class="co1">//EOF</SPAN></PRE>
</DD></DL>

</DIV>
<!-- SECTION "Řešený příklad - zpracování pole v cyklu" [49539-50279] -->
<H2><A name="samostatna_cviceni2" id="samostatna_cviceni2">Samostatná cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Pomocí dvou vnořených cyklů naplňte dvojrozměrné pole znaků (char[x][y]) šachovnicí (8×8) z 1 a 0, pomocí dalšího vnořeného cyklu ji pak vytiskněte</DIV>
<UL>
<LI class="level2"><DIV class="li"> Velikost šachovnice bude možno libovolně měnit pomocí dvou proměnných (int x = 8, y = 8;).</DIV>
</LI>
<LI class="level2"><DIV class="li"> Očekávaný výsledek: <PRE class="code">01010101
10101010
01010101
10101010
01010101
10101010
01010101
10101010
</PRE>
</DIV>
</LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"> Upravte program z předchozího cvičení tak, aby byly protilehlé rohy spojeny osmičkami.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Upravte program z předchozího cvičení tak, aby byl čtverec lemován nulami.</DIV>
<UL>
<LI class="level2"><DIV class="li">Očekávaný výsledek: <PRE class="code">00000000
08101080
01810800
00188010
01088100
00801810
08010180
00000000
</PRE>
</DIV>
</LI>
</UL>
</LI>
</UL>

</DIV>
<!-- SECTION "Samostatná cvičení" [50280-51000] -->
<H1><A name="argumenty_programu" id="argumenty_programu">Argumenty programu</A></H1>
<DIV class="level1">

<P>
Další možností, jak můžeme našemu programu předat nějaká data, je to, že mu je zdělíme už při spouštění. To se provádí pomocí tzv. argumentů (můžeme se také setkat s pojmem parametry), ty předáme programu tak, že je napíšeme za jeho název oddělené mezerami. To je přesně to, k čemu dochází pokud např. ve vašem operačním systému otevíráte nějaký textový dokument, video nebo cokoli v jiném programu. V takovém případě grafické prostředí, které pravděpodobně používáte k ovládání počítače vyvolá příkaz podobný těmto:

</P>
<UL>
<LI class="level1"><DIV class="li"> prehravac_filmu film.avi</DIV>
</LI>
<LI class="level1"><DIV class="li"> cesta/super\ jukebox jedna\ pisnicka.ogg „druha - pisnicka.mp3“</DIV>
</LI>
<LI class="level1"><DIV class="li"> „c:\program files\msoffice\word\word.exe“ dokument.doc</DIV>
</LI>
</UL>

<P>

Můžeme si všimnout, že všechny parametry jsou odděleny mezerami, pokud je nutné, aby parametr obsahoval mezeru, dáme ho buď do uvozovek, nebo před mezeru dáme zpětné lomítko (to se na windows nepoužívá), pokud ovšem potřebujeme, aby argument obsahoval uvozovku, dáme před ni také zpětné lomítko.
</P>

<P>
Také by bylo dobré poznamenat, že prvním argumentem (i když se takto neoznačuje) je vždy název programu.
</P>

</DIV>
<!-- SECTION "Argumenty programu" [51001-52217] -->
<H2><A name="argumenty_z_hlediska_programatora" id="argumenty_z_hlediska_programatora">Argumenty z hlediska programátora</A></H2>
<DIV class="level2">

<P>
Operační systém předává našemu programu argumenty pomocí dvou proměnných.
První z nich je int argc, která obsahuje počet argumentů, pokud tedy například předáme programu dva argumenty, tak bude platit, že argc == 3, protože kromě těchto dvou souborů bylo programu předáno ještě jméno spustitelného souboru (tedy název programu).
Druhou proměnnou, která už obsahuje data konkrétních argumentů je char *argv[], jde o pole řetězců, to tedy znamená, že např. argv[0] bude první argument (název programu), argv[1] druhý, atd…
</P>

<P>
Aby náš program mohl od systému parametry převzít, musíme je nadeklarovat v hlavičce funkce main(), tedy např.:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> argc<SPAN class="sy0">,</SPAN> <SPAN class="kw4">char</SPAN> <SPAN class="sy0">*</SPAN>argv<SPAN class="br0">[</SPAN><SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="co1">//Telo programu</SPAN>
<SPAN class="br0">}</SPAN></PRE>

</DIV>
<!-- SECTION "Argumenty z hlediska programátora" [52218-53026] -->
<H2><A name="padam_padas_padame" id="padam_padas_padame">Padám, padáš, padáme!</A></H2>
<DIV class="level2">

<P>
V případě, že by se náš program pokusil přistupovat k nezadanému argumentu, dojde k jeho pádu, protože operační systém toto místo (kde náš argument není) již používá k jiným účelům a je nežádoucí, aby k němu náš program získal přístup. Je tedy vhodné pomocí hodnoty argc vždy ověřovat, jestli konkrétní argument existuje. V opačném případě bychom se mohli od operačního systému dočkat ukončení programu a vypsání podobné chybové hlášky: „Neoprávněný přístup do paměti (SIGSEGV)“, nebo známější anglická hláška „Segmentation fault. Core dumped.“.
</P>

<P>
Takové ošetření by mohlo vypadat například takto:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> argc<SPAN class="sy0">,</SPAN> <SPAN class="kw4">char</SPAN> <SPAN class="sy0">*</SPAN>argv<SPAN class="br0">[</SPAN><SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>argc <SPAN class="sy0">&gt;</SPAN> 1<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
		<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Byl zadán argument %s<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> argv<SPAN class="br0">[</SPAN>1<SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="br0">}</SPAN> <SPAN class="kw1">else</SPAN> <SPAN class="br0">{</SPAN>
		<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Nebyl zadán žádný argument!<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="br0">}</SPAN>
<SPAN class="br0">}</SPAN></PRE>

</DIV>
<!-- SECTION "Padám, padáš, padáme!" [53027-53917] -->
<H2><A name="reseny_priklad2" id="reseny_priklad2">Řešený příklad</A></H2>
<DIV class="level2">
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=26" title="St&aacute;hnout snippet" class="mediafile mf_c">args.c</A></DT>
<DD><PRE class="code file c"><SPAN class="coMULTI">/* args.c
 * Napiste program, ktery vypise pocet parametru, prvni parametr a nasledujici dva secte jako cela cisla a vypise ve tvaru rovnice
 */</SPAN>
&nbsp;
<SPAN class="co2">#include &lt;stdio.h&gt;</SPAN>
<SPAN class="co2">#include &lt;stdlib.h&gt;</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> argc<SPAN class="sy0">,</SPAN> <SPAN class="kw4">char</SPAN> <SPAN class="sy0">*</SPAN>argv<SPAN class="br0">[</SPAN><SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw4">int</SPAN> x<SPAN class="sy0">,</SPAN> y<SPAN class="sy0">;</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Pocet parametru: %d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> argc<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Jmeno programu: %s<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> argv<SPAN class="br0">[</SPAN>0<SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	x <SPAN class="sy0">=</SPAN> atoi<SPAN class="br0">(</SPAN>argv<SPAN class="br0">[</SPAN>1<SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	y <SPAN class="sy0">=</SPAN> atoi<SPAN class="br0">(</SPAN>argv<SPAN class="br0">[</SPAN>2<SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Prvni scitanec: %d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> x<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Druhy scitanec: %d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> y<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Vysledek: %d+%d = %d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> x<SPAN class="sy0">,</SPAN> y<SPAN class="sy0">,</SPAN> <SPAN class="br0">(</SPAN>x<SPAN class="sy0">+</SPAN>y<SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>
</DD></DL>

</DIV>
<!-- SECTION "Řešený příklad" [53918-54450] -->
<H2><A name="vystup_programu" id="vystup_programu">Výstup programu:</A></H2>
<DIV class="level2">
<PRE class="code">harvie@harvie-ntb:~/Desktop/skripta/c$ ./args 2 3
Pocet parametru: 3
Jmeno programu: ./args
Prvni scitanec: 2
Druhy scitanec: 3
Vysledek: 2+3 = 5
</PRE>

<P>

Nyní se program pokusí přistupovat k neexistujícímu argumentu:

</P>
<PRE class="code">harvie@harvie-ntb:~/Desktop/skripta/c$ ./args 2
Pocet parametru: 2
Jmeno programu: ./args
Neoprávněný přístup do paměti (SIGSEGV)
</PRE>

</DIV>
<!-- SECTION "Výstup programu:" [54451-54861] -->
<H2><A name="samostatna_cviceni3" id="samostatna_cviceni3">Samostatná cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> upravte předchozí příklad tak, aby kontroloval počet parametrů a v případě jejich neexistence použil místo daného sčítance nulu.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Napište program, který pomocí cyklu while vypíše všechny argumenty pod sebe.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Napište program, který pomocí cyklu for vypíše všechny argumenty pod sebe.</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Samostatná cvičení" [54862-55215] -->
<H1><A name="preprocesor" id="preprocesor">Preprocesor</A></H1>
<DIV class="level1">

<P>
Už jsme si nastínili, že než se námi napsaný zdrojový kód dostane do kompilátoru, projde vyčištěním, doplněním a částečnou optimalizací v tzv. preprocesoru. Nyní si ukážeme, jak používat některé jeho direktivy (funkce), předtím je snad jen dobré poznamenat, že direktivy preprocesoru se označují znakem # (hash,mřížka,křížek,sharp).
</P>

</DIV>
<!-- SECTION "Preprocesor" [55216-55613] -->
<H2><A name="inkludovani_-_vkladani_jineho_souboru" id="inkludovani_-_vkladani_jineho_souboru">Inkludování - vkládání jiného souboru</A></H2>
<DIV class="level2">

<P>
Preprocesor nám umožňuje vložit do zdrojového kódu veškerý obsah jiného souboru, této direktivy využijeme např. při odděleném překladu, nebo při vkládání hlavičkových souborů různých knihoven. Například inkludováním &lt;stdio.h&gt; si zpřístupníme Ansi C funkce pro práci s textovým vstupem a výstupem (klávesnice, obrazovka, soubory).
</P>

<P>
Vložení probíhá pomocí direktivy pomocí direktivy #include, např.:
</P>
<PRE class="code c"><SPAN class="co2">#include &lt;stdio.h&gt; //Se špičatými závorkami se soubor hledá v adresáři, kde má překladač standartní hlavičkové soubory (jako je stdio.h)</SPAN>
<SPAN class="co2">#include "mujprogram.h" //S uvozovkami se soubor hledá ve stejném adresáři, jako je náš zdrojový kód, pokud není nalezen, hledá se ve standartním adresáři</SPAN>
<SPAN class="co2">#include NAZEV_KONSTANTY //Viz. symbolické konstanty</SPAN></PRE>

<P>
Musíme si ale dávat pozor, aby jsme omylem neinkludovali sami sebe, nebo jiný soubor, který inkluduje nás, to by pravděpodobně vedlo k zaseknutí preprocesoru v nekonečné smyčce. Jak tomu předcházet: viz. podmíněný překlad.
</P>

</DIV>
<!-- SECTION "Inkludování - vkládání jiného souboru" [55614-56743] -->
<H2><A name="symbolicke_konstanty" id="symbolicke_konstanty">Symbolické konstanty</A></H2>
<DIV class="level2">

<P>
Rozdílem použití této konstanty (ve srvonání např. s definicí běžné konstanty) je to, že ji nelze po kompilaci měnit, protože preprocesor představuje z tohoto hlediska pouze pomůcku, která vyhledá v kódu identifikátory makra a nahradí je hodnotou tohoto makra (asi jako to dělá váš oblíbený textový editor pomocí funkce „najít a nahradit“). To je výhodné např. pro uchování číselných hodnot (dříve se makra používala k definici velikosti statického pole, dnes již musí Ansi C podle normy umět alokovat pole za běhu, aby bylo možné jeho velikost určit pomocí proměnné), naopak jsou makra nevhodná například pro uchování větších řetězců, které používáme na více místech (rozkopírování několika stejných desítek bytů na několik míst v kódu nikomu ještě nepřidalo).
</P>

<P>
Použití:
</P>

<P>
Nahradit všechny výskyty NAZEV_MAKRA textem retezec:
</P>
<PRE class="code">#define NAZEV_KONSTANTY [retezec]</PRE>

<P>

Zrušit definici makra NAZEV_KONSTANTY:
</P>
<PRE class="code">#undef NAZEV_KONSTANTY</PRE>

<P>

Jak jste si mohli všimnout, je zvykem psát identifikátory symbolických konstant celé velkými písmeny (opět až na vyjímky), abychom je oddělili od normálních proměnných.
</P>

</DIV>
<!-- SECTION "Symbolické konstanty" [56744-57978] -->
<H2><A name="makra" id="makra">Makra</A></H2>
<DIV class="level2">

<P>
<EM>Pokud jste ještě nečetli kapitolu Funkce, tak následující odstavec klidně přeskočte.</EM>
</P>

<P>
Také existují ještě zajímavější druhy symbolických konstant a těmi jsou makra, ty se liší tím, že obsahují (podobně jako funkce) argumenty, takové nám mohou nahradit menší funkci, to sice také prodlužuje kód (a velikost výsledného programu), ale nadruhou stranu tím ušetříme čas na volání funkce (což může být někdy poměrně dost), o případných zbytečných automatických přetypování a přiřazování ani nemluvě.
</P>

<P>
Použití:
</P>
<PRE class="code">#define nasobek(a,b) ((a)*(b))</PRE>

<P>

zápis:
</P>
<PRE class="code">nasobek(1,2)</PRE>

<P>
se potom rozvine na:
</P>
<PRE class="code">((1)*(2))</PRE>

<P>

Zde musíme dát pozor na závorky, pokud bychom napsali jen: #define nasobek(a,b) a*b, mohlo by se nám potom stát, že makro použijeme (slovo zavoláme by nebylo příliš vhodné) například tímto způsobem:
</P>
<PRE class="code">int i = nasobek(2+3,1+2)*7</PRE>

<P>
pak by se makro rozvinulo v:
</P>
<PRE class="code">int i = 2+3*1+2*7</PRE>

<P>
a to je úplně jiný výraz než námi předpokládaný
</P>
<PRE class="code">int i = ((2+3)*(1+2))*7</PRE>

</DIV>
<!-- SECTION "Makra" [57979-59036] -->
<H2><A name="podmineny_preklad_podminky_preprocesoru" id="podmineny_preklad_podminky_preprocesoru">Podmíněný překlad (podmínky preprocesoru)</A></H2>
<DIV class="level2">

<P>
Podmíněný překlad je možnost preprocesoru vypouštět některé části kódu na základě toho, jestli je definována nějaká symbolická konstanta, typicky jde o potlačení ladících výpisů (které by nám v případě, že je zakážeme pomocí běžné podmínky if() a například čísla, kterým je ovládáme zbytečně okupovali prostor v paměti a výkon procesoru).
</P>

<P>
Použití:
</P>
<PRE class="code c"><SPAN class="co2">#define LADIT //Budeme ladit</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="co1">//nejake prikazy</SPAN>
	<SPAN class="co2">#if defined(LADIT)</SPAN>
		<SPAN class="co1">//ladici prikazy	</SPAN>
	<SPAN class="co2">#endif</SPAN>
<SPAN class="br0">}</SPAN></PRE>

<P>
Dalším využitím podmíněného překladu je například předcházení zacykleným inkludováním, následující soubor se nenainkluduje dvakrát:
</P>
<PRE class="code c"><SPAN class="co2">#define UZ_INKLUDOVANO</SPAN>
<SPAN class="co2">#ifndef UZ_INKLUDOVANO</SPAN>
	<SPAN class="co1">//Zamysleny obsah souboru</SPAN>
<SPAN class="co2">#endif</SPAN></PRE>

</DIV>
<!-- SECTION "Podmíněný překlad (podmínky preprocesoru)" [59037-59875] -->
<H2><A name="preddefinovane_symbolicke_konstanty_preprocesoru" id="preddefinovane_symbolicke_konstanty_preprocesoru">Předdefinované symbolické konstanty preprocesoru</A></H2>
<DIV class="level2">

<P>
Z preprocesoru můžeme také zjišťovat různé informace a zařídit se podle nich, k tomu nám pomůžou předdefinované symbolické konstanty mezi ně patří např.:
</P>
<UL>
<LI class="level1"><DIV class="li"> Datum a čas překladu</DIV>
</LI>
<LI class="level1"><DIV class="li"> Soubor a řádek ve zdrojovém kódu</DIV>
</LI>
<LI class="level1"><DIV class="li"> Operační systém</DIV>
</LI>
<LI class="level1"><DIV class="li"> Verze C / Podpora C++</DIV>
</LI>
<LI class="level1"><DIV class="li"> Další informace o cílovém systému</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Předdefinované symbolické konstanty preprocesoru" [59876-60272] -->
<H1><A name="funkce_-_uvod" id="funkce_-_uvod">Funkce - úvod</A></H1>
<DIV class="level1">

<P>
Při programování neustále voláme nějaké funkce, funkci, která nám vypíše to, zjistí tamto, vypočítá tohle, ukončí program, otevře soubor, čte ze souboru a takřka cokoli složitějšího děláme pomocí funkcí.
</P>

</DIV>
<!-- SECTION "Funkce - úvod" [60273-60534] -->
<H2><A name="volani_funkce" id="volani_funkce">Volání funkce</A></H2>
<DIV class="level2">

<P>
Volání funkce (jak už víme) probíhá například zápisem:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> b <SPAN class="sy0">=</SPAN> <SPAN class="nu0">4</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="kw4">int</SPAN> y <SPAN class="sy0">=</SPAN> secti<SPAN class="br0">(</SPAN>1<SPAN class="sy0">,</SPAN> b<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>

<P>
Podobný zápis předá jedničku a hodnotu proměnné int b funkci secti() a do proměnné x nám uloží návratovou hodnotu funkce (konkrétně tohoto callu - neboli zavolání). Tuto hodnotu není nutné nikam ukládat. Můžeme ji také např. použít v jiném výrazu, jako argument jiné funkce, nebo dokonce prostě zahodit/nepoužít.
</P>

</DIV>
<!-- SECTION "Volání funkce" [60535-61024] -->
<H2><A name="definice_funkce" id="definice_funkce">Definice funkce</A></H2>
<DIV class="level2">

<P>
Ovšem se nám může stát, že budeme potřebovat použít jeden algoritmus, nebo blok kódu na více místech našeho programu a pokud bychom ho jen rozkopírovali, nebo (dokonce) opsali, byli bysme pro smích všem programátorům (včetně začátečníků). Napíšeme si tedy vlastní funkci, je to jednoduché:
</P>
<PRE class="code c"><SPAN class="co1">//Definice nasi prvni funkce - nachazi se mimo funkci main()</SPAN>
<SPAN class="kw4">int</SPAN> secti<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> prvni<SPAN class="sy0">,</SPAN> <SPAN class="kw4">int</SPAN> druhe<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> <SPAN class="co1">//Sem za hlavicku funkce je dobre psat jednoduchy popis funkce (napr. "secte dve cisla int")</SPAN>
	<SPAN class="co1">//Telo funkce secti():</SPAN>
	<SPAN class="kw4">int</SPAN> x<SPAN class="sy0">;</SPAN>
	x <SPAN class="sy0">=</SPAN> prvni<SPAN class="sy0">+</SPAN>druhe<SPAN class="sy0">;</SPAN> <SPAN class="co1">//Secteme prvni a druhe a ulozime do x</SPAN>
	<SPAN class="kw1">return</SPAN> x<SPAN class="sy0">;</SPAN> <SPAN class="co1">//Vratime x</SPAN>
<SPAN class="br0">}</SPAN> <SPAN class="co1">//Pozor!!! tady jiz neni strednik</SPAN>
&nbsp;
<SPAN class="co1">//A nyni muzeme vyzkouset nas stary dobry ukazkovy kod</SPAN>
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> argc<SPAN class="sy0">,</SPAN> <SPAN class="kw4">char</SPAN> <SPAN class="sy0">*</SPAN>argv<SPAN class="br0">[</SPAN><SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> <SPAN class="co1">//Volani ale jiz provedeme z funkce main():</SPAN>
	<SPAN class="kw4">int</SPAN> b <SPAN class="sy0">=</SPAN> <SPAN class="nu0">4</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw4">int</SPAN> y <SPAN class="sy0">=</SPAN> secti<SPAN class="br0">(</SPAN>1<SPAN class="sy0">,</SPAN> b<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"%d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> x<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>

</DIV>
<!-- SECTION "Definice funkce" [61025-61917] -->
<H2><A name="pravidla" id="pravidla">Pravidla</A></H2>
<DIV class="level2">

<P>
Při psaní nových funkcí samozřejmě také platí jistá pravidla, například to jsou:

</P>
<UL>
<LI class="level1"><DIV class="li"> Identifikátor nové funkce nesmí být použit ničím jiným (zdá se to zřejmé, ale pokud bychom například chtěli nadefinovat novou funkci printf(), tak neuspějeme, i když platí jisté vyjímky).</DIV>
</LI>
<LI class="level1"><DIV class="li"> Typ vraceného čísla (return hodnoty) musí být stejný jako typ funkce například funkce int secti() nemůže vracet hodnotu čísla float x, můžeme se také spolehnout na tzv. automatické přetypování tedy např.: <PRE class="code c"><SPAN class="kw4">int</SPAN> secti<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> a<SPAN class="sy0">,</SPAN> <SPAN class="kw4">int</SPAN> b<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> <SPAN class="kw1">return</SPAN> a<SPAN class="sy0">+</SPAN>b<SPAN class="sy0">;</SPAN> <SPAN class="br0">}</SPAN> <SPAN class="co1">//Tato funkce je hezčejší a rychlejšejší než ta, co jsme si ukázali.</SPAN></PRE>
</DIV>
</LI>
<LI class="level1"><DIV class="li"> Na konci definice fce nepíšeme (stejně jako například za cykly) středník! (jde o hloupou, ale častou chybu).</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Pravidla" [61918-62728] -->
<H2><A name="parametry_funkce" id="parametry_funkce">Parametry funkce</A></H2>
<DIV class="level2">

<P>
Funkci předáváme parametry (tím, jak to ve skutečnosti probíhá v procesoru se zatím zatěžovat nebudeme), jsou to např. nějaká čísla, se kterými můžeme ve funkci dále pracovat. Rozlišujeme dvoje parametry - tzv. skutečné parametry a tzv. formální parametry.

</P>
<UL>
<LI class="level1"><DIV class="li"> Skutečný parametr je ten, kterým funkci voláme, tedy například při volání secti(2,3); jsou 2 a 3 skutečnými parametry funkce secti().</DIV>
</LI>
<LI class="level1"><DIV class="li"> Formální parametr je ten, se kterým pracujeme v těle funkce, tedy například ve funkci s hlavičkou int secti(int prvni, int druhe); tyto dvě a všechny ostatní proměnné, které vytvoříme v těle funkce nijak neovlivňují zbytek programu a mohou se jmenovat stejně (mít stejný identifikátor) jako např. jiná proměnná ve funkci main().</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Parametry funkce" [62729-63549] -->
<H2><A name="navratova_hodnota" id="navratova_hodnota">Návratová hodnota</A></H2>
<DIV class="level2">

<P>
Návratová hodnota je cokoli, co funkce vrátí (zavoláním funkce return(), nebo dosažením konce funkce), vždy jde o stejný datový typ, jako je typ funkce (návratová hodnota je jakousi hodnotou této funkce). Pokud nezavoláme funkci return(), ale funkce se ukončí dosažením konce svého kódu, je automaticky vrácena 0.
</P>

</DIV>
<!-- SECTION "Návratová hodnota" [63550-63918] -->
<H2><A name="cviceni" id="cviceni">Cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Vysvětlete zjednodušeně, co znamená hlavička funkce main(): int main(int argc, char *argv[]) { /*Nejaky kod*/ }</DIV>
</LI>
<LI class="level1"><DIV class="li"> Čím je funkce main() specifická?</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Cvičení" [63919-64102] -->
<H2><A name="samostatna_cviceni4" id="samostatna_cviceni4">Samostatná cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Napište co nejjednodušší funkci, která korektně umocní dvě čísla typu float (jedno druhým).</DIV>
</LI>
<LI class="level1"><DIV class="li"> Napište funkci, která vypíše „hello, world\n“ tolikrát, kolik bude hodnota jediného parametru typu int.</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Samostatná cvičení" [64103-64358] -->
<H1><A name="globalni_promenne_pretezovani_funkci_funkcni_prototypy_rekurzivni_funkce" id="globalni_promenne_pretezovani_funkci_funkcni_prototypy_rekurzivni_funkce">Globální proměnné, přetěžování funkcí, funkční prototypy, rekurzivní funkce</A></H1>
<DIV class="level1">

<P>
Minule jsme si ukázali základy práce s funkcemi, dnes si to ještě o něco ztížíme.
</P>

</DIV>
<!-- SECTION "Globální proměnné, přetěžování funkcí, funkční prototypy, rekurzivní funkce" [64359-64553] -->
<H2><A name="globalni_promenna" id="globalni_promenna">Globální proměnná</A></H2>
<DIV class="level2">

<P>
Říkali jsme si, že pokud ve funkci pracujeme s proměnnými, tyto neovlivňují zbytek programu, naopak ani nemůžeme pracovat s jinými proměnnými v programu (funkce běží v jiném tzv. kontextu). Pokud bychom ale stejně chtěli nadefinovat proměnnou, která bude použitelná v celém programu (má tzv. Globální viditelnost), můžeme to udělat například její definicí/deklarací mimo funkci main, takový kód by vypadal zhruba takto:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> vypis_x<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"x = %d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> x<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="br0">}</SPAN> <SPAN class="co1">//Vypise globalni promennou x</SPAN>
<SPAN class="kw4">int</SPAN> inc_x<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> x<SPAN class="sy0">++;</SPAN> <SPAN class="br0">}</SPAN> <SPAN class="co1">//Zvetsi globalni promennou x o 1</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> x <SPAN class="sy0">=</SPAN> <SPAN class="nu0">2</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Globalni prommena x = 2</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> argc<SPAN class="sy0">,</SPAN> <SPAN class="kw4">char</SPAN> <SPAN class="sy0">*</SPAN>argv<SPAN class="br0">[</SPAN><SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> <SPAN class="co1">//Hlavni funkce (ta se vetsinou nekomentuje!)</SPAN>
	vypis_x<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	x <SPAN class="sy0">=</SPAN> <SPAN class="nu0">4</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//x = 4</SPAN>
	inc_x<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//x = 5</SPAN>
	vypis_x<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	x <SPAN class="sy0">=</SPAN> inc_x<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//x = 0 (funkce inc_x() sice x zvysi na 6, ale nasledne vrati hodnotu 0, ktera je zde do x prirazena)</SPAN>
	vypis_x<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>

<P>
Můžeme si všimnout, že když definujeme novou funkci, děláme to také raději mimo fci main(), tato naše funkce je pak „viditelná“ (dostupná) kdekoli.
</P>

</DIV>
<!-- SECTION "Globální proměnná" [64554-65657] -->
<H2><A name="pretezovani_funkci" id="pretezovani_funkci">Přetěžování funkcí</A></H2>
<DIV class="level2">

<P>
Psal jsem, že identifikátor funkce nesmí s ničím kolidovat. To není tak úplně pravda. Můžeme mít několik funkcí se stejným jménem, ale jiným počtem neby typem parametrů, nejlépe to je vidět na následujícím příkladu:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> secti<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> a<SPAN class="sy0">,</SPAN> <SPAN class="kw4">int</SPAN> b<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> <SPAN class="kw1">return</SPAN> a<SPAN class="sy0">+</SPAN>b<SPAN class="sy0">;</SPAN> <SPAN class="br0">}</SPAN>
<SPAN class="kw4">int</SPAN> secti<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> a<SPAN class="sy0">,</SPAN> <SPAN class="kw4">int</SPAN> b<SPAN class="sy0">,</SPAN> <SPAN class="kw4">int</SPAN> c<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> <SPAN class="kw1">return</SPAN> a<SPAN class="sy0">+</SPAN>b<SPAN class="sy0">+</SPAN>c<SPAN class="sy0">;</SPAN> <SPAN class="br0">}</SPAN>
<SPAN class="kw4">int</SPAN> secti<SPAN class="br0">(</SPAN><SPAN class="kw4">char</SPAN> c<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> putc c<SPAN class="sy0">;</SPAN> <SPAN class="br0">}</SPAN></PRE>

<P>
Pak pomocí volání secti() můžeme sečíst dvě, nebo tři čísla (a nemusíme tedy přemýšlet, jak se jmenuje funkce na sečtení tří čísel), pokud zavoláme secti() s jedním parametrem typu char, tak dokonce tato funkce udělá něco úplně jiného a to je vypsání znaku (což je stejně nečekané, jako sčítání s jedním číslem ;).
</P>

</DIV>
<!-- SECTION "Přetěžování funkcí" [65658-66432] -->
<H2><A name="funkcni_prototypy" id="funkcni_prototypy">Funkční prototypy</A></H2>
<DIV class="level2">

<P>
Zatím jsme vždy funkci definovali jen před místem, kde jsme ji použili (to je logické, protože proměnnou také musíme vždy nejdříve nadefinovat, než s ní začneme pracovat). Mohlo by se ale stát, že otevřeme soubor se zdrojovým kódem našeho programu, a než se dostaneme k funkci main(), která obsahuje hlavní logiku našeho programu, budeme se muset prokousat spoustou pomocných funkcí, které pro nás nemají tak velký význam.
</P>

<P>
Můžeme tedy funkci nad main() jen „nadeklarovat“ (toto označení není úplně na místě, ale přesto je takřka pravdivé) a napsat (nadefinovat) ji níže. Tomu se říká použití funkčního prototypu. Funkční prototyp je vlastně pouze hlavička dané funkce zakončená středníkem. Funkční prototyp také nemusí obsahovat seznam parametrů (a jejich datových typů), v tom případě ale funkci nelze přetěžovat a kompilátor neví jaké parametry má očekávat (jede odzhora dolů) a proto nemůže opravit chyby jako volání s nesprávným počtem, nebo typem parametrů, které takřka vždy musí skončit s oblíbenou hláškou „Segmentation fault“, neboli neoprávněný přístup do paměti.
</P>

<P>
V případě, že používáme funkční prototypy, tak stručný komentář píšeme k prototypu, nikoli k tělu funkce.
</P>

<P>
Bývá také zvykem, že se funkční prototypy dávají do hlavičkového souboru (viz. kapitola Preprocesor), který se jmenuje stejně jako náš zdrojový kód, s tím rozdílem, že místo přípony .c má příponu .h, to je užitečné, pokud chceme tyto funkce používat i v jiných souborech našeho projektu (tomu se říká tzv. oddělená kompilace). Tento hlavičkový soubor se pak includuje nejen do našeho zdrojového kódu, ale do všech dalších souborů, které chtějí mít k těmto funkcím přístup.
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> tisk<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> x<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Funkce vypise prvni parametr jako int a vrati jeho dvojnasobek (pozor, tady strednik pro zmenu je!)</SPAN>
<SPAN class="co1">//int tisk(); //Toto je druha moznost zapisu funkcniho prototypu, tedy bez parametru...</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> argc<SPAN class="sy0">,</SPAN> <SPAN class="kw4">char</SPAN> <SPAN class="sy0">*</SPAN>argv<SPAN class="br0">[</SPAN><SPAN class="br0">]</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	tisk<SPAN class="br0">(</SPAN>4<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> tisk<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> x<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"%d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> x<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>

</DIV>
<!-- SECTION "Funkční prototypy" [66433-68610] -->
<H2><A name="rekurzivni_funkce" id="rekurzivni_funkce">Rekurzivní funkce</A></H2>
<DIV class="level2">

<P>
Rekurzivní funkce je funkce, které volá sama sebe, musíme ale pamatovat na to, že pokud nebude počet rekurzivních volání konečný, tak bude nekonečný, to v praxi znamená, že takový program se logicky zasekne v nekonečné smyčce, což vyústí v jednu ze tří věcí. Buď dojde paměť, nebo jiné prostředky, program začne velmi špatně hospodařit s časem CPU a „vycucne“ výkon, který potřebují jiné programy, nebo zůstane stát na místě a dokola opakovat nějakou jednoduchou akci.
</P>

<P>
Možná není na první pohled zřejmé, k čemu jsou takové funkce dobré, uvedu vám tedy příklad z praxe, který jsem sám několikrát použil a je používaný ve spoustě programů. Představte si, že potřebujete vypsat, nebo prohledat obsah adresáře včetně podadresářů a jejich podadresářů, atd… Jak to tedy uděláme? Jednoduše si napíšeme funkci, která otevře zvolený kořenový adresář (jeho jméno se předává jako parametr) a projíždí si ho položku po položce, když narazí na soubor, tak ho zpracuje (např. vypíše jeho název), pokud ale narazí na adresář, tak ho nejen vypíše, ale potom ještě rekurzivně zavolá sama sebe a předá si cestu k tomuto adresáři tak, že k názvu kořenového adresáře připojí jméno adresáře k prohledání, aby vznikla celá cesta. Dovedete si tedy představit, že ve finále si tímto postupem projedeme všechny složky a podsložky a jejich podsložky ve zvoleném adresáři.
</P>

<P>
Takže rekurzivní funkce jsou velmi výhodné, je-li třeba operovat například nad nějakými stromovými strukturami, na druhou stranu se ale dají použít i jinak než ke zkoumání nebo vytváření (např. kreslení) stromů.
</P>

<P>
Tady je příklad jednoduché rekurzivní fce:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> rekurze<SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN> x<SPAN class="sy0">,</SPAN> <SPAN class="kw4">int</SPAN> y<SPAN class="sy0">,</SPAN> <SPAN class="kw4">int</SPAN> z<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>x<SPAN class="sy0">&gt;</SPAN>z<SPAN class="br0">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="br0">(</SPAN>rekurze<SPAN class="br0">(</SPAN>x<SPAN class="sy0">-</SPAN>y<SPAN class="sy0">,</SPAN> y<SPAN class="sy0">,</SPAN> z<SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw1">return</SPAN><SPAN class="br0">(</SPAN>x<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>

<P>
Pokud tuto funkci zavoláme (např.: rekurze(10, 1, 0);), bude volat sama sebe a postupně odečítat od zadaného parametru x parametr y, dokud nebude platit, že x⇐z, pak vrátí x, v našem případě bude návratem hodnota 0.
</P>

</DIV>
<!-- SECTION "Rekurzivní funkce" [68611-70757] -->
<H2><A name="samostatna_cviceni5" id="samostatna_cviceni5">Samostatná cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Napište rekurzivní funkci, která vypíše „hello, world\n“ tolikrát, kolik bude hodnota jediného parametru typu int.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Nadefinujte globální proměnnou typu int a napište funkci, která zvětší její hodnotu o číslo zadané jako parametr.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Tuto funkci přetěžte a udělejte druhou, která sečte nejdřív dva parametry dohromady a pak toto číslo teprve přičte k vaší globální proměnné.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Pro tyto dvě funkce vytvořte funkční prototypy a přesuňte jejich kód pod funkci main(), ve které je odzkoušejte.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Zkuste vypočítat, kolikrát se zavolá fce rekurze() z výkladu (výše) při volání rekurze(10, 1, 0);, potom to vyzkoušejte, použijte k tomu globální proměnnou int a.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Co funkce vratí pro hodnoty 4 a 3?: <PRE class="code c"><SPAN class="kw4">int</SPAN> ff1<SPAN class="br0">(</SPAN>x<SPAN class="sy0">,</SPAN> y<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw1">if</SPAN> <SPAN class="br0">(</SPAN>x<SPAN class="sy0">&gt;</SPAN>0<SPAN class="br0">)</SPAN> <SPAN class="kw1">return</SPAN> ff1<SPAN class="br0">(</SPAN>x<SPAN class="sy0">-</SPAN>1<SPAN class="sy0">,</SPAN> y<SPAN class="br0">)</SPAN><SPAN class="sy0">+</SPAN><SPAN class="nu0">1</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw1">return</SPAN> y<SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>
</DIV>
</LI>
<LI class="level1"><DIV class="li"> Co funkce vratí pro hodnoty 2 a 7?: <PRE class="code c"><SPAN class="kw4">int</SPAN> ff2<SPAN class="br0">(</SPAN>x<SPAN class="sy0">,</SPAN> y<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw1">if</SPAN> <SPAN class="br0">(</SPAN>x <SPAN class="sy0">&lt;</SPAN> y<SPAN class="br0">)</SPAN> <SPAN class="kw1">return</SPAN> ff2<SPAN class="br0">(</SPAN>x<SPAN class="sy0">+</SPAN>1<SPAN class="sy0">,</SPAN>y<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw1">return</SPAN> x<SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>
</DIV>
</LI>
<LI class="level1"><DIV class="li"> Co funkce vratí pro hodnoty 2 a 4?: <PRE class="code c"><SPAN class="kw4">int</SPAN> ff3<SPAN class="br0">(</SPAN>x<SPAN class="sy0">,</SPAN> y<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw1">if</SPAN> <SPAN class="br0">(</SPAN>x <SPAN class="sy0">==</SPAN> 0<SPAN class="br0">)</SPAN> <SPAN class="kw1">return</SPAN> <SPAN class="nu0">0</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw1">return</SPAN> ff3<SPAN class="br0">(</SPAN>x<SPAN class="sy0">-</SPAN>1<SPAN class="sy0">,</SPAN>y<SPAN class="br0">)</SPAN><SPAN class="sy0">+</SPAN>y<SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>

<P>
====== Pointery (ukazatele) ======
</P>
</DIV>
</LI>
</UL>

<P>
Doteď platilo, že když jsme potřebovali pracovat s nějakým kusem paměti (proměnnou), jednoduše jsme ji nadeklarovali (nebo nadefinovali) a kompilátor se za nás postaral o to, aby se po spuštění programu nalézala v paměti a my s ní mohli pracovat.
</P>

</DIV>
<!-- SECTION "Samostatná cvičení" [70758-72176] -->
<H2><A name="referencovani" id="referencovani">Referencování</A></H2>
<DIV class="level2">

<P>
Základní operací kterou musíme znát je použití referenčního (&amp; - Ampersand) a dereferenčního (* - Hvězdička) operátoru.
</P>

<P>
Pokud aplikujeme referenční operátor na některou z proměnných (nebo cokoli jiného, co je fyzicky uložené v paměti), dostaneme adresu v paměti, na které je tento objekt umístěn. Např. následující kód, který by normálně měl vytisknout hexadecimální (šestnáctkovou) interpretaci hodnoty proměnné cislo nám díky operátoru “&amp;“ před identifikátorem proměnné vytiskne adresu v paměti (na které je samozřejmě uložen obsah naší proměnné).
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> cislo <SPAN class="sy0">=</SPAN> <SPAN class="nu0">2</SPAN><SPAN class="sy0">;</SPAN>
<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"0x%X<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> <SPAN class="sy0">&amp;</SPAN>cislo<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>

<P>
Nutno ještě podotknout, že bývá zvykem, že se šestnáctkové číslo (to, které vypíšeme pomocí “%x“ nebo “%X“) pro rozlišení od čísel v jiných číselných soustavách (desítkové, dvojkové, osmičkové) zapisuje s „0x“ na začátku, formátovací řetězec pro 'slušné' vypsání čísla v šestnáctkovém tvaru pomocí standartní funkce printf() (adresy v paměti a adresy vůbec nebývá zvykem udávat jinak než šestnáctkově) by tedy vypadal například takto: „0x%X“, s odřádkováním pak takto: „0x%X\n“.
</P>

<P>
A proč se operátoru “&amp;“ říká „referenční“? Je to jednoduše proto, že nám vrací referenci (neboli odkaz) na proměnnou a sice v podobě její adresy.
</P>

</DIV>
<!-- SECTION "Referencování" [72177-73577] -->
<H2><A name="dereferencovani" id="dereferencovani">Dereferencování</A></H2>
<DIV class="level2">

<P>
Ještě užitečnější možností, než je referencování je možnost tzv. dereference. Dereferencování nám umožňuje naopak pracovat s pamětí, pokud známe její adresu. Dereferencování probíhá pomocí operátoru „*“. To můžete vidět na následujícím příkladu:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> data<SPAN class="sy0">,</SPAN> adresa<SPAN class="sy0">;</SPAN>
&nbsp;
data <SPAN class="sy0">=</SPAN> <SPAN class="nu0">32</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Inicializace promenne</SPAN>
adresa <SPAN class="sy0">=</SPAN> <SPAN class="sy0">&amp;</SPAN>data<SPAN class="sy0">;</SPAN> <SPAN class="co1">//Do promenne adresa ulozime adresu promenne data (pomoci referencovani)</SPAN>
<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"0x%X<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> adresa<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Vytiskneme si adresu</SPAN>
<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"%d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> <SPAN class="sy0">*</SPAN>adresa<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Na promennou adresa pouzijeme dereferencni operator a vytiskneme tedy hodnotu promenne data</SPAN>
&nbsp;
<SPAN class="sy0">*</SPAN>adresa <SPAN class="sy0">=</SPAN> <SPAN class="nu0">23</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Zapiseme 23 do pameti urcene adresou ulozenou v promenne adresa</SPAN>
<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"%d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> data<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Tim, ze jsme zapisovali na adresu ziskanou referenci romenne data, jsme zmenili i hodnotu promene data</SPAN>
&nbsp;
<SPAN class="co1">//Nyni lze tedy tvrdit, ze hodnoty data a *adresa jsou to same.</SPAN>
<SPAN class="co1">//Stejne jsou i hodnoty &amp;data a adresa.</SPAN></PRE>

<P>
Pokud používáme proměnnou pouze na uložení jiné adresy a pomocí dereference přes ní přistupujeme k datům na této adrese, takové proměnné říkáme pointer. Toto označení není špatné ani v případě, že jím titulujeme přímo tuto adresu.
</P>

<P>
Dalším pěkným příkladem může být také toto:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> data<SPAN class="sy0">;</SPAN>
<SPAN class="sy0">*</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">&amp;</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">*</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">&amp;</SPAN>data<SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="sy0">=</SPAN> <SPAN class="nu0">32</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//To je to same jako: data = 32;</SPAN></PRE>

</DIV>
<!-- SECTION "Dereferencování" [73578-74932] -->
<H2><A name="neopravneny_pristup_do_pameti" id="neopravneny_pristup_do_pameti">Neoprávněný přístup do paměti</A></H2>
<DIV class="level2">

<P>
Neoprávněný přístup do paměti je zatím asi jediná chyba, která nás při programování potkala, pokud tedy mluvíme o chybách, které neodchytí kompilátor (nebo preprocesor), ale nastanou až za běhu programu. V podstatě jde o to, že pokud se program pokusí číst nebo zapisovat do paměti, kterou si nealokoval (tudíž je buď volná, nebo patří někomu jinému), systém ho zarazí a z bezpečnostních důvodů ukončí (takový přístup může signalizovat, že se někdo pokouší program nabourat, nebo sám o sobě způsobit jiné škody).
</P>

<P>
Jak si takový neoprávněný přístup nasimulovat?
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> <SPAN class="sy0">*</SPAN>a<SPAN class="sy0">,</SPAN> b<SPAN class="sy0">;</SPAN>
a <SPAN class="sy0">=</SPAN> <SPAN class="nu0">31337</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Toto je vymyslena adresa, ktera pravdepodobne nepatri nasemu programu (teoreticky by mohla, ale pravdepodobnost je celkem miziva)</SPAN>
<SPAN class="sy0">*</SPAN>a <SPAN class="sy0">=</SPAN> <SPAN class="nu0">32</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Pokusime se zapsat na neplatnou adresu -&gt; Pad programu</SPAN>
b <SPAN class="sy0">=</SPAN> <SPAN class="sy0">*</SPAN>a<SPAN class="sy0">;</SPAN> <SPAN class="co1">//Pokusime se cist z neplatne adresy -&gt; Taktez Segmentation fault (sem se uz program nedostane, protoze havaroval)</SPAN></PRE>

</DIV>
<!-- SECTION "Neoprávněný přístup do paměti" [74933-75965] -->
<H2><A name="spravna_deklarace_pointeru" id="spravna_deklarace_pointeru">Správná deklarace pointerů</A></H2>
<DIV class="level2">

<P>
Všiměte si, že jsem v nadpisu použil slovo deklarace pointerů, nikoli definice. To proto, že adresa uchovávaná v pointeru by měla být zjištěna až za běhu programu. Pokud jí zapíšeme přímo do kódu, tak program buď spadne, nebo bude-li fungovat, tak jenom někde a někdy, podle toho, co na dané adrese je.
</P>

<P>
Chceme li tedy vytvořit pointer například na integer, uděláme to takto:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> <SPAN class="sy0">*</SPAN>cislo<SPAN class="sy0">,</SPAN> a<SPAN class="sy0">;</SPAN>
cislo <SPAN class="sy0">=</SPAN> <SPAN class="sy0">&amp;</SPAN>a<SPAN class="sy0">;</SPAN> <SPAN class="co1">//inicializace</SPAN></PRE>

<P>
S tím jsme se již setkali v předchozích příkladech, ale já jsem to záměrně nechal až na konec.
Proč je u pointeru nutné určit, na jaký datový typ bude ukazovat si povíme později. Pro nás je ale důleřité, že pointer nezabírá tolik místa, jako může být nutné pro uložení dat, která budou na cílové adrese. To si jednak musíme uvědomit při deklaraci a za druhé nám to může urychlit program tak, že nějaké funkci předáme pouze pointer (ta ho musí očekávat) a funkce tak pracuje skrze tento pointer (adresu) přímo nad našimi daty, aniž by se vytvářela jejich kopie v kontextu funkce. Této možnosti se říká předání odkazem a dalo by se to přirovnat k situaci ze skutečného života, kdy potřebujete vykonat nějakou stavební úpravu a můžete (s nadsázkou) buď odnést celý dům k zedníkovi, nebo můžete zedníkovi donést jen papírek s adresou tohoto domu (tedy pointer).
</P>

</DIV>
<!-- SECTION "Správná deklarace pointerů" [75966-77415] -->
<H1><A name="dynamicka_alokace_pameti" id="dynamicka_alokace_pameti">Dynamická alokace paměti</A></H1>
<DIV class="level1">

<P>
Než začneme s dynamickou alokací paměti, je ještě je dobré vědět, že je slušné, dobré, praktické, důležité a nevím jaké ještě to, že pokud máme pointer na neexistující objekt (v C znamená pojem objekt něco jiného, než v oběktových, nebo objektově orientovaných jazycích), tak bysme měli tento pointer nastavit na hodnotu NULL (my se spokojíme s přiřazením 0), takovému pointeru se pak říká nulový pointer, nebo pointer na NULL. Například takto:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> a<SPAN class="sy0">,</SPAN> b<SPAN class="sy0">;</SPAN>
a <SPAN class="sy0">=</SPAN> <SPAN class="sy0">&amp;</SPAN>b<SPAN class="sy0">;</SPAN>
<SPAN class="sy0">*</SPAN>a <SPAN class="sy0">=</SPAN> <SPAN class="nu0">32</SPAN><SPAN class="sy0">;</SPAN>
a <SPAN class="sy0">=</SPAN> NULL<SPAN class="sy0">;</SPAN> <SPAN class="co1">//Zrusime pointer</SPAN></PRE>

</DIV>
<!-- SECTION "Dynamická alokace paměti" [77416-78021] -->
<H2><A name="funkce_pro_dynamicke_pridelovani_pameti" id="funkce_pro_dynamicke_pridelovani_pameti">Funkce pro dynamické přidělování paměti</A></H2>
<DIV class="level2">

<P>
Abychom mohli využívat tyto funkce, musíme nainkludovat hlavičku stdlib.h (tedy: #include &lt;stdlib.h&gt;). Je pravděpodobné, že na některých kompilátorech (především těch z GNU rodiny) by se vám program zkompiloval i bez vložení tohoto hlavičkového souboru, protože jde o jeden z nejzákladnějších, tak je možné, že již je nainkludován, ale to není dobře, protože pokud se takový program pokusíte zkompilovat jinde, tak se vám to nepodaří, to také vyčtete z varovných hlášek, kterými vás gcc poučí, pokud soubor nenainkludujete. Jde především o funkce malloc() a free(). První z nich nám umožní za běhu programu alokovat potřebné množství paměti, ta druhá ji potom zase dokáže uvolnit (tedy navrátit operačnímu systému a umožnit tak její využití k jiným účelům).
</P>

</DIV>
<!-- SECTION "Funkce pro dynamické přidělování paměti" [78022-78912] -->
<H2><A name="funkce_malloc" id="funkce_malloc">Funkce malloc()</A></H2>
<DIV class="level2">

<P>
Tato funkce přijímá jediný parametr, kterým je počet bytů, které si má od <ACRONYM title="Operating System">OS</ACRONYM> vyžádat, potom vrátí pointer na alokované místo (jeho první byte). Pokud se z nějakého důvodu nepodaří tuto paměť získat, malloc() vrací nulový pointer. Když potřebujeme alokovat např. integer, musíme si zjistit, jakou velikost má int na našem kompilátoru. Již víme, že se to provádí pomocí operátoru sizeof(), tedy sizeof(int). Následující příklad ukazuje správnou alokaci a inicializaci dvou integerů, jeden staticky, druhý za běhu programu:
</P>
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=48" title="St&aacute;hnout snippet" class="mediafile mf_c">dynamic.c</A></DT>
<DD><PRE class="code file c"><SPAN class="co2">#include &lt;stdlib.h&gt;</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw4">int</SPAN> a<SPAN class="sy0">,</SPAN> <SPAN class="sy0">*</SPAN>b<SPAN class="sy0">;</SPAN>
	b <SPAN class="sy0">=</SPAN> NULL<SPAN class="sy0">;</SPAN> <SPAN class="co1">//Pro jistotu a ze zvyku priradime do b nulu (abychom se omylem nepokusili pracovat s cizi pameti)</SPAN>
&nbsp;
	a <SPAN class="sy0">=</SPAN> <SPAN class="nu0">2600</SPAN><SPAN class="sy0">;</SPAN>
&nbsp;
	b <SPAN class="sy0">=</SPAN> malloc<SPAN class="br0">(</SPAN><SPAN class="kw4">sizeof</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Pokusime se alokovat pamet o velikosti integeru</SPAN>
	<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN>b<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> <SPAN class="co1">//Pokud se nam nepodari alokovat pamet</SPAN>
		<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Chyba pri malloc()!<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Vypiseme chyb. hlasku</SPAN>
		exit<SPAN class="br0">(</SPAN>1<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//A skoncime s chybovym kodem 1</SPAN>
	<SPAN class="br0">}</SPAN>
&nbsp;
	<SPAN class="sy0">*</SPAN>b <SPAN class="sy0">=</SPAN> <SPAN class="nu0">1337</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>
</DD></DL>

<P>
Možná je dobré vědět, že operačnímu systému se nemusí vždy hodit množství paměti, jaké vyžadujete a přidělí vám trochu víc (nebo samozřejmně nic, tedy NULL).
</P>

</DIV>
<!-- SECTION "Funkce malloc()" [78913-80136] -->
<H2><A name="funkce_free" id="funkce_free">Funkce free()</A></H2>
<DIV class="level2">

<P>
Funkci předáme jako parametr pointer/adresu již předem alokované paměti, funkce se postará o to, aby byla tato paměť uvolněna a navrácena <ACRONYM title="Operating System">OS</ACRONYM> k dalšímu použití. Věřím, že na demonstraci postačí jednoduchý příklad:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> <SPAN class="sy0">*</SPAN>a<SPAN class="sy0">;</SPAN>
a <SPAN class="sy0">=</SPAN> NULL<SPAN class="sy0">;</SPAN>
a <SPAN class="sy0">=</SPAN> malloc<SPAN class="br0">(</SPAN><SPAN class="kw4">sizeof</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN>a<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Chyba pri malloc()!<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	exit<SPAN class="br0">(</SPAN>1<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN>
<SPAN class="sy0">*</SPAN>a <SPAN class="sy0">=</SPAN> <SPAN class="nu0">31337</SPAN><SPAN class="sy0">;</SPAN>
&nbsp;
free<SPAN class="br0">(</SPAN>a<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Uvolnime pamet</SPAN>
a <SPAN class="sy0">=</SPAN> NULL<SPAN class="sy0">;</SPAN> <SPAN class="co1">//Pointer, ktery ukazuje na "cizi pudu" nastavime na NULL</SPAN></PRE>

<P>
Takže si musíme pamatovat, že takový pointer, který nám zůstal po uvolnění funkcí free() musíme co možná nejdříve nastavit na NULL. Nebývá žádnou zvláštností, když se tyto dvě neoddělitelné operace zapisují na jeden řádek (kompaktnější vzhled a logika kódu):

</P>
<PRE class="code">free(a); a = NULL;</PRE>

</DIV>
<!-- SECTION "Funkce free()" [80137-80939] -->
<H2><A name="kam_se_starym_smetim" id="kam_se_starym_smetim">Kam se starým smetím?</A></H2>
<DIV class="level2">

<P>
Může se nám také díky nějaké chybě v logice programu, nebo nějaké jiné nepozornosti stát, že budeme alokovat a alokovat paměť, ale už ji zapomeneme uvolňovat. A protože C (ani C++) nemá tzv. Garbage collector (Sběrač smetí), musíme uvolnit paměť, než pointer na ní zahodíme. Z následujícího příkladu by to mělo být jasné:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> <SPAN class="sy0">*</SPAN>data<SPAN class="sy0">;</SPAN>
data <SPAN class="sy0">=</SPAN> malloc<SPAN class="br0">(</SPAN><SPAN class="kw4">sizeof</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
data <SPAN class="sy0">=</SPAN> malloc<SPAN class="br0">(</SPAN><SPAN class="kw4">sizeof</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Alokujeme podruhe, tim prijdeme o adresu prvniho alokovaneho prostoru, a uz nikdy se nam ho nepodari uvolnit</SPAN></PRE>

<P>
Většinou se samozřejmě paměť uvolní při ukončení programu (<ACRONYM title="Operating System">OS</ACRONYM> by měl uvolnit vše, co po programu v paměti zbylo), ale určitě nelze 100% věřit tomu, že například M$ Windows někde sem tam něco nezapomenou. Zkuste si například tento kód:

</P>
<PRE class="code">while(1) malloc(1024);</PRE>

<P>

Otevřete si správce procesů (htop, top, tasklist, taskmgr) a zjistěte, kolik paměti náš proces zabírá (virtuální, fyzické i celkové). Pošlete procesu signál pro ukončení (nebo ukočete program, jak jste na vašem <ACRONYM title="Operating System">OS</ACRONYM> zvyklí) a sledujte, jak se paměť pomalu uvolňuje.
</P>

</DIV>
<!-- SECTION "Kam se starým smetím?" [80940-82106] -->
<H2><A name="opakovaci_ukazka_pointeru_a_dynamicke_alokace_pameti" id="opakovaci_ukazka_pointeru_a_dynamicke_alokace_pameti">Opakovací ukázka pointerů a dynamické alokace paměti</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Ujistěte se, že chápete celý následující kód, v opačném případě se okamžitě obraťte na nejbližšího profesora (nebo rychle utečte).</DIV>
</LI>
<LI class="level1"><DIV class="li"> Předpovězte, co program zhruba vypíše a svoje doměnky si vyvraťte jeho kompilací a spuštěním:</DIV>
</LI>
</UL>
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=51" title="St&aacute;hnout snippet" class="mediafile mf_c">hadanka.c</A></DT>
<DD><PRE class="code file c"><SPAN class="co2">#include &lt;stdio.h&gt;</SPAN>
<SPAN class="co2">#include &lt;stdlib.h&gt;</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
&nbsp;
        <SPAN class="kw4">int</SPAN> prvni<SPAN class="sy0">;</SPAN> <SPAN class="co1">//Staticky (za prekladu) alokovana promenna typu int</SPAN>
&nbsp;
        <SPAN class="kw4">int</SPAN> <SPAN class="sy0">*</SPAN>druha<SPAN class="sy0">;</SPAN> <SPAN class="co1">//Staticky alokovany pointer na promennou typu int</SPAN>
        druha <SPAN class="sy0">=</SPAN> malloc<SPAN class="br0">(</SPAN><SPAN class="kw4">sizeof</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">int</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Dynamicky (za behu) alokovana promenna typu int</SPAN>
        <SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN>druha<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
                <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Chyba!<SPAN class="es1">\n</SPAN>Nepodarilo se alokovat promennou *druha<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
                exit<SPAN class="br0">(</SPAN>1<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
        <SPAN class="br0">}</SPAN>
&nbsp;
        prvni <SPAN class="sy0">=</SPAN> <SPAN class="nu0">11</SPAN><SPAN class="sy0">;</SPAN>
        prvni <SPAN class="sy0">=</SPAN> <SPAN class="nu0">22</SPAN><SPAN class="sy0">;</SPAN>
        prvni <SPAN class="sy0">=</SPAN> <SPAN class="sy0">*</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">&amp;</SPAN>prvni<SPAN class="br0">)</SPAN><SPAN class="sy0">+</SPAN><SPAN class="nu0">1</SPAN><SPAN class="sy0">;</SPAN>
        <SPAN class="co1">//druha = 22; //Ukazkova chyba -&gt; SIGSEGV</SPAN>
        <SPAN class="sy0">*</SPAN>druha <SPAN class="sy0">=</SPAN> <SPAN class="nu0">22</SPAN><SPAN class="sy0">;</SPAN>
&nbsp;
        <SPAN class="co1">//Hodnoty promennych</SPAN>
        <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Hodnoty promennych:<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
        <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"prvni == %d<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> prvni<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
        <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"druha == %d<SPAN class="es1">\n</SPAN><SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> <SPAN class="sy0">*</SPAN>druha<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
&nbsp;
        <SPAN class="co1">//Vypis adres, na kterych jsou promenne ulozeny</SPAN>
        <SPAN class="co1">//Desitkove a pak hexadecimalne (s prefixem 0x)</SPAN>
        <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Adresy v promennych pameti:<SPAN class="es1">\n</SPAN><SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
        <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"prvni je na %d = 0x%X<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> <SPAN class="sy0">&amp;</SPAN>prvni<SPAN class="sy0">,</SPAN> <SPAN class="sy0">&amp;</SPAN>prvni<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
        <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"druha je na %d = 0x%X<SPAN class="es1">\n</SPAN><SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="sy0">,</SPAN> druha<SPAN class="sy0">,</SPAN> druha<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
&nbsp;
        free<SPAN class="br0">(</SPAN>druha<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Uvolnime alokovanou pamet</SPAN>
&nbsp;
        exit<SPAN class="br0">(</SPAN>0<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Na konci programu se samozrejme teoreticky uvolni vse</SPAN>
&nbsp;
<SPAN class="br0">}</SPAN></PRE>
</DD></DL>

</DIV>
<!-- SECTION "Opakovací ukázka pointerů a dynamické alokace paměti" [82107-83588] -->
<H1><A name="dynamicka_pole" id="dynamicka_pole">Dynamická pole</A></H1>
<DIV class="level1">

<P>
V této kapitole si představíme způsob, kterým můžeme pracovat s polem alokovaným až za běhu programu.
</P>

</DIV>
<!-- SECTION "Dynamická pole" [83589-83731] -->
<H2><A name="alokace" id="alokace">Alokace</A></H2>
<DIV class="level2">

<P>
Na následujícím příkladu si ukážeme, jak je to doopravdy s definicí (nebo deklarací) polí.
</P>
<PRE class="code c"><SPAN class="kw4">unsigned</SPAN> <SPAN class="kw4">char</SPAN> <SPAN class="kw4">static</SPAN><SPAN class="br0">[</SPAN>10<SPAN class="br0">]</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="kw4">unsigned</SPAN> <SPAN class="kw4">char</SPAN> <SPAN class="sy0">*</SPAN>dynamic<SPAN class="sy0">;</SPAN></PRE>

<P>
V obou případech vytvoříme pointer na char (případně pole), jediný rozdíl je v tom, že static je konstanta, kterou nelze měnit a obsahuje pointer na již alokované místo v paměti (to se alokovalo při definici), ale dynamic neobsahuje nic (resp. není inicializovaný) a nealokuje žádné místo (alokuje pouze místo pro sebe).
</P>

<P>
Takže když chceme dynamic začít používat stejně jako static, stačí nám použít tento zápis:
</P>
<PRE class="code c"><SPAN class="kw4">unsigned</SPAN> <SPAN class="kw4">char</SPAN> <SPAN class="kw4">static</SPAN><SPAN class="br0">[</SPAN>10<SPAN class="br0">]</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="kw4">unsigned</SPAN> <SPAN class="kw4">char</SPAN> <SPAN class="sy0">*</SPAN>dynamic<SPAN class="sy0">;</SPAN> <SPAN class="co1">//Deklarace pointeru na char (případně pole charů)</SPAN>
&nbsp;
dynamic <SPAN class="sy0">=</SPAN> malloc<SPAN class="br0">(</SPAN>10<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Alokujeme 10 bytů a pointer na ně přiřadíme do pole</SPAN>
<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN>dynamic<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Nelze alokovat paměť!<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	exit<SPAN class="br0">(</SPAN>1<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>

<P>
Nyní můžeme k oběma polím přistupovat následujícím způsobem:
</P>
<PRE class="code c"><SPAN class="kw4">static</SPAN><SPAN class="br0">[</SPAN><SPAN class="nu0">3</SPAN><SPAN class="br0">]</SPAN> <SPAN class="sy0">=</SPAN> <SPAN class="st0">'a'</SPAN><SPAN class="sy0">;</SPAN>
dynamic<SPAN class="br0">[</SPAN><SPAN class="nu0">3</SPAN><SPAN class="br0">]</SPAN> <SPAN class="sy0">=</SPAN> <SPAN class="st0">'a'</SPAN><SPAN class="sy0">;</SPAN>
&nbsp;
<SPAN class="sy0">*</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">static</SPAN> <SPAN class="sy0">+</SPAN> 3 <SPAN class="sy0">*</SPAN> <SPAN class="kw4">sizeof</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">char</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="sy0">=</SPAN> <SPAN class="st0">'a'</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="sy0">*</SPAN><SPAN class="br0">(</SPAN>dynamic <SPAN class="sy0">+</SPAN> 3 <SPAN class="sy0">*</SPAN> <SPAN class="kw4">sizeof</SPAN><SPAN class="br0">(</SPAN><SPAN class="kw4">char</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="sy0">=</SPAN> <SPAN class="st0">'a'</SPAN><SPAN class="sy0">;</SPAN></PRE>

<P>
Jak vidíte, k oběma polím (jak statickému tak dynamickému) můžeme přistupovat naprosto totožným způsobem, tedy pomocí operátoru [], který (jak jsme nyní zjistili) také zahrnuje dereferenci, nebo pomocí čistě dereferenčního operátoru a pointerové aritmetiky.
</P>

</DIV>
<!-- SECTION "Alokace" [83732-85122] -->
<H2><A name="pokrocile_postupy" id="pokrocile_postupy">Pokročilé postupy</A></H2>
<DIV class="level2">

<P>
Pokud potřebujeme pole o proměnné velikosti, tak jediným možným způsobem zůstává vždy alokovat nové pole (o jiné velikosti) a stará data do něj v cyklu přetáhnout. Je samozřejmě vhodné staré pole uvolnit (pomocí free()).
</P>

</DIV>
<!-- SECTION "Pokročilé postupy" [85123-85398] -->
<H2><A name="preteceni_bufferu" id="preteceni_bufferu">Přetečení bufferu</A></H2>
<DIV class="level2">

<P>
Dobré je také vědět, že pokud načítáme jakákoli data od uživatele (např. z argumentů, klávesnice, sítě nebo souboru) a chceme je uložit do pole (např. řetězce), musíme pohlídat, aby data nepřetekla nad velikost pole, v takovém případě by mohlo dojít k pádu programu pokud by programu byl předán příliš dlouhý řetězec, nebo dokonce zápisu nebezpečného kódu na významná místa v paměti, pokud by se někdo pokusil program napadnout záměrně. Je tedy nutné si hlídat, jestli nepřekračujeme maximální offsety pole.
</P>

</DIV>
<!-- SECTION "Přetečení bufferu" [85399-85995] -->
<H2><A name="samostatna_cviceni6" id="samostatna_cviceni6">Samostatná cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Napište program, který dokáže do statického pole načíst z klávesnice libovolný řetězec tak, aby nebyla přesažena velikost pole. Nezapomeňte na to, že poslední znak pole musí být nulový.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Vytvořte obdobu předchozího programu, s tím, že se pole alokuje dynamicky.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Zkuste napsat program tak, aby zvládl načíst libovolně dlouhý řetězec do pole o proměnné velikosti.</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Samostatná cvičení" [85996-86435] -->
<H1><A name="spousteni_externich_programu" id="spousteni_externich_programu">Spouštění externích programů</A></H1>
<DIV class="level1">

<P>
Tato kapitola by měla nastínit, jakým způsobem je možné zavolat externí program (příkaz), stejně, jako byste ho třeba napsali do příkazové řádky.
</P>

</DIV>
<!-- SECTION "Spouštění externích programů" [86436-86646] -->
<H2><A name="funkce_system" id="funkce_system">Funkce system()</A></H2>
<DIV class="level2">

<P>
Funkce system() dokáže spustit příkaz a to dokonce s využitím operátorl příkazového interpretu (např.: &lt;,&gt;,»,|), ten jí předáme jako obyčejný řetězec, tedy například system(„ls“);, s tím, že výstup tohoto příkazu bude vypsán na obrazovku.
</P>

<P>
Samozřejmě si musíme uvědomit, že ve chvíli, kdy použijeme podobné volání externího programu, se náš (relativně přenositelný) program stává závislý na existenci daného příkazu na cílové platformě. Tedy například pokud budeme chtít uživateli zobrazit seznam souborů voláním příkazu „ls“, program nám bude bezproblémově fungovat na většině UNIXových systémů naopak na Windows bychom museli tento příkaz změnit na „dir“.
</P>

<P>
V případě, že je nezbytně nutné volat externí programy, je dobré na začátku programu nadefinovat symbolické konstanty s cestou k tomuto programu, nebo příkazy například načítat z nějakého konfiguračního souboru, který se bude pro každou platformu lišit, také je možné aby náš program nějakým způsobem automaticky ověřoval, jestli program existuje, nebo třeba od někud zjistil, na jaké běží platformě a podle toho se zařídil.
</P>

</DIV>
<!-- SECTION "Funkce system()" [86647-87876] -->
<H2><A name="dalsi_funkce_pro_praci_s_externimi_programy" id="dalsi_funkce_pro_praci_s_externimi_programy">Další funkce pro práci s externími programy</A></H2>
<DIV class="level2">

<P>
Existuje spousta dalších funkcí, které vám umožní pokročilejší práci se spustitelnými soubory, jako je například nahrazení našeho programu v paměti jiným, spuštění na pozadí, otevření procesu jako souboru a čtení a zápis dat na jeho I/O.
</P>

</DIV>
<!-- SECTION "Další funkce pro práci s externími programy" [87877-88202] -->
<H1><A name="prace_s_promennymi_prostredi" id="prace_s_promennymi_prostredi">Práce s proměnnými prostředí</A></H1>
<DIV class="level1">

<P>
Proměnné prostředí jsou proměnné, které nám poskytuje program, který náš program spouští (většinou příkazový řádek, nebo grafické prostředí). Tyto proměnné jsou nahrány do paměti našeho programu spolu s jeho kódem.
</P>

<P>
Typickou proměnnou prostředí je „PATH“, proměnná, ve které jsou uložené cesty k adresářům, ve kterých se hledá program, který se pokoušíme spustit, pokud není nalezen v aktuálním adresáři. Pokud vás zajímá, jaké další proměnné váš <ACRONYM title="Operating System">OS</ACRONYM> běžně poskytuje, zkuste si příkazy export na UNIXech, nebo set na Windows, pomocí těchto příkazů lze také nastavit nové proměnné, nebo změnit stávající. Existuje funkce getenv(), která nám vrátí pointer na danou proměnnou. Následující příklad ukazuje, jak vytisknout námi zvolenou proměnnou prostředí:
</P>
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=55" title="St&aacute;hnout snippet" class="mediafile mf_c">getenv-path.c</A></DT>
<DD><PRE class="code file c"><SPAN class="co2">#include &lt;stdio.h&gt;</SPAN>
<SPAN class="co2">#include &lt;stdlib.h&gt;</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main <SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN>
<SPAN class="br0">{</SPAN>
  <SPAN class="kw4">char</SPAN> <SPAN class="sy0">*</SPAN>p<SPAN class="sy0">;</SPAN>
  p <SPAN class="sy0">=</SPAN> getenv<SPAN class="br0">(</SPAN> <SPAN class="st0">"PATH"</SPAN> <SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
  <SPAN class="kw1">if</SPAN> <SPAN class="br0">(</SPAN>p <SPAN class="sy0">!=</SPAN> NULL<SPAN class="br0">)</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A> <SPAN class="br0">(</SPAN><SPAN class="st0">"PATH: %s"</SPAN><SPAN class="sy0">,</SPAN> p<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>
</DD></DL>

</DIV>
<!-- SECTION "Práce s proměnnými prostředí" [88203-89259] -->
<H1><A name="vetveni_procesu_paralelni_zpracovani_programu" id="vetveni_procesu_paralelni_zpracovani_programu">Větvení procesu, paralelní zpracování programu</A></H1>
<DIV class="level1">

</DIV>
<!-- SECTION "Větvení procesu, paralelní zpracování programu" [89260-89325] -->
<H2><A name="funkce_fork" id="funkce_fork">Funkce fork()</A></H2>
<DIV class="level2">

<P>
Pokud potřebujeme v našem programu opustit lineární řízení, jinak řečeno - dělat dvě (a více) věcí najednou. Můžeme pomocí systémového volání fork() vytvořit dokonalou kopii procesu našeho programu, která se bude lišit pouze tím, že návratová hodnota fork() v ní bude 0 a samozřejmě bude mít jiné PID (identifikační číslo procesu). Volání fork() (neboli větvení) je výsadou pouze UNIXových (a samozřejmě UNIX-Like) systémů a na <ACRONYM title="Microsoft">MS</ACRONYM> Windows bychom podobnou věc museli řešit jinak a daleko složitěji.
</P>

<P>
Abych vás nenapínal, tady je první příklad:
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>fork<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="coMULTI">/* Tento kod se bude jiz provadet na pozadi... */</SPAN>
	sleep<SPAN class="br0">(</SPAN>10<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"BAF!<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>

<P>
V našem případě jsem zavolali fork() hned na začátku programu, tím se vytvořili kopii našeho procesu, v originále se návratová hodnota volání fork() rovnala 1, to jsme ověřili podmínkou, takže v prvním procesu se nám vykonal return() a tím pádem se první proces zavřel. Máme tedy nový proces, který ovšem není tak pevně svázán s naší příkazovou řádkou a ta se tedy uvolní (a budeme moci normálně dále pracovat a spouštět další programy). Protože se nám ale v procesu nakopírovalo číslo file deskriptoru (ukazatele na soubor), pomocí kterého se dá vypisovat do konzole (na STDOUT), může náš tak trochu záškodnický program na pozadí za 10 sekund vypsat nic netušícímu uživateli „BAF!“ a to klidně doprostřed výpisu jiného programu (podobně, jako se vám třeba v BASHi můžou vypisovat oznámení o nových mailech).
</P>

<P>
Spuštění programu na pozadí je ale pouze začátkem toho, co fork() doopravdy umí. Podívejme se na následující kód.:
</P>
<PRE class="code c">	<SPAN class="coMULTI">/* nejaky kod */</SPAN>
	<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN>fork<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
		udelej_neco<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
		<SPAN class="kw1">return</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="br0">}</SPAN>
	<SPAN class="coMULTI">/* dalsi kod */</SPAN></PRE>

<P>
V tomto případě se zavolá na pozadí pouze funkce udelej_neco() a program bude ihned pokračovat dále. Typickým příkladem může být stahování nějakého velkého souboru (nebo více souborů) z webového serveru (pro zjednodušení jsem použil externí program wget volaný pomocí system()):
</P>
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=58" title="St&aacute;hnout snippet" class="mediafile mf_c">fork.c</A></DT>
<DD><PRE class="code file c"><SPAN class="co2">#include &lt;stdio.h&gt;</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN>fork<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> system<SPAN class="br0">(</SPAN><SPAN class="st0"><SPAN>"wget <A class="linkclass" href="http://server/soubor1">http://server/soubor1</A>"</SPAN></SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="br0">}</SPAN>
	<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN>fork<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> system<SPAN class="br0">(</SPAN><SPAN class="st0"><SPAN>"wget <A class="linkclass" href="http://server/soubor2">http://server/soubor2</A>"</SPAN></SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="br0">}</SPAN>
	<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN>fork<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> system<SPAN class="br0">(</SPAN><SPAN class="st0"><SPAN>"wget <A class="linkclass" href="http://server/soubor3">http://server/soubor3</A>"</SPAN></SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="br0">}</SPAN>
	<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN><SPAN class="sy0">!</SPAN>fork<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> system<SPAN class="br0">(</SPAN><SPAN class="st0"><SPAN>"wget <A class="linkclass" href="http://server/soubor4">http://server/soubor4</A>"</SPAN></SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="kw1">return</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="br0">}</SPAN>
	<SPAN class="kw1">return</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>
</DD></DL>

<P>
Tím docílíme toho, že se budou všechny 4 soubory stahovat najednou a ne jeden podruhém, jako kdybychom pouze 4x pod sebou zavolali system(). Díky tomu, že jsem do podmínky přidal vikřičník jsem si zajistil to, že se soubor bude stahovat v kopii a nikoli v originálním procesu. Původnímu procesu se říká parrent (rodič) a kopie se označuje jako child (dítě) i když v případě fork() jsou oba procesy spíše bratry či sestřičkami. Důležité je také to, že po stažení souboru zavoláme return(), protože kdybychom to neudělali, tak by se každý soubor mohl stáhnout vícekrát, protože se náš program v paměti zkopíroval i s tím, co má dělat potom.
</P>

<P>
Stinnou stránkou celé věci je to, že jednotlivé procesy se nemohou vzájemně příliš dorozumívat, musíme pak přistoupit k použití prostředků jako jsou soubory, pojmenované pajpy (fifo roury), unix domain sockety a nebo dokonce síťové sockety.
</P>

<P>
Další věcí je, že náš program bude velmi těžkopádný, pokud budeme používat fork() ve větším měřítku, například pokud bychom psali webový (nebo jiný) server, tak musíme obsluhovat více uživatelů najednou. Pokud bychom ale na každého uživatele vytvořili jednu kopii procesu, může se nám stát, že nám brzo začnou docházet systémové prostředky (mluvíme o serverech s ~100 requesty najednou), pokud nám nedojdou hardwarové prostředky, tak se nám zaplní process table (vyčerpáme maximální počet procesů povolený operačním systémem), proto je lepší počet 'forků' omezit a ještě lépe používat thready (viz. dále).
</P>

<P>
Pro zájemce: Existuje lokální DoS útok pojmenovaný ForkBomb, který způsobí zaplnění tabulky procesů a vede neodvratně k zamrznutí systému, protože nelze vytvořit žádný nový proces, nemůžeme ani spustit program, který by útok ukončil. Uvádím to proto, že k podobné věci může dojít pokud někde voláme fork() v cyklu (např. potřebujeme n podprocesů) a omylem vytvoříme nekonečnou smyčku.
</P>

<P>
Např. takto:

</P>
<PRE class="code">while(1) fork();</PRE>

<P>

Na UNIXových systémech se dá proti nečekané chybě bránit tím, že nastavíme limit počtu procesů pro každého uživatele, v případě podobného výmrzu můžeme jako jiný uživatel (typicky root) procesy pozabíjet. Na Windows proti této chybě takřka není ochrana. A ačkoli v jádře systému Windows nic jako fork() neexistuje, může nastat podobný problém, pokud se nám omylem podaří to, že jeden program neustále spouští sám sebe.
</P>

</DIV>
<!-- SECTION "Funkce fork()" [89326-94393] -->
<H2><A name="thready" id="thready">Thready</A></H2>
<DIV class="level2">

<P>
Další možností jak může náš program dělat více věcí najednou jsou takzvané thready (vlákna) ty se od forku liší v tom, že nejde o kopii procesu, ale jeho součást. Thread je tím pádem jakýsi podřadný proces. Narozdíl od forku existují thready i na Windows. Další výhodou je, že thready mohou dále komunikovat se zbytkem procesu, například pomocí globálních proměnných (například proměnné deklarované mimo funkci main()), potom je ale třeba hlídat, aby se dva thready nepokusily zapisovat do stejné proměnné (== stejného místa v paměti), potom by mohlo dojít k poškození těchto společných dat. K tomu se používá tzv. synchronizace threadů. Práce s thready už je ale složitější a proto si ji zde nebudeme ukazovat…
</P>

</DIV>
<!-- SECTION "Thready" [94394-95196] -->
<H2><A name="samostatna_cviceni7" id="samostatna_cviceni7">Samostatná cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Napište program, který vypíše, na jakém místě se v paměti nachází proměnná prostředí, jejíž název byl zadán jako parametr.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Napište program, který vezme všechny argumenty (kromě prvního), spojí je do jednoho řetězce (oddělené mezerami) a výslednou větu vytiskne orámovanou znakem (případně prvním znakem řetězce), který je udaný prvním argumentem (vlevo a vpravo bude jeden znak mezera). Výsledný výstup pak mže vypadat napříkad takto:</DIV>
</LI>
</UL>
<PRE class="code">./ramecek * "Ahoj lidi," jak\ se máte?
***************************
* Ahoj lidi, jak se máte? *
***************************</PRE>

</DIV>
<!-- SECTION "Samostatná cvičení" [95197-95853] -->
<H1><A name="prace_se_soubory" id="prace_se_soubory">Práce se soubory</A></H1>
<DIV class="level1">

<P>
Doteď jsme naše data ukládali jen do paměti RAM. O všechna data uložená v  paměti RAM přijdeme v okamžiku ukončení programu, nebo vypnutí počítače. To nemusí bý vždy postačující a můžeme chtít svoje data uložit nějakým trvanlivějším způsobem, ideálním řešením bude jejich zapsání na pevný disk, konkrétně do souboru.
</P>

<P>
Klasickým příkladem práce se soubory je jednoduchý tetový editor (nano, gedit, SciTE, notepad, atd…). Takový editor při svém spuštění načte zvolený soubor do paměti, kde s ním může uživatel pracovat a před svým ukončením tato data z paměti uloží i s úpravami zpět do souboru na příslušném paměťovém médiu.
</P>

<P>
Ovšem si pamatujte, že problematika základní práce se soubory je mnohem komplikovanější, než jak je zde popsána a pokud máte zájem, doporučuji si projít odkazy na konci této publikace.
</P>

</DIV>
<!-- SECTION "Práce se soubory" [95854-96791] -->
<H2><A name="otevreni_souboru" id="otevreni_souboru">Otevření souboru</A></H2>
<DIV class="level2">

<P>
Abychom mohli pracovat se souborem, musíme ho nejdříve otevřít. Se soubory se dá pracovat například pomocí tzv. file deskriptorů, neo také ukazatelů (je to podobné, jako nám již známé pointery, s tím rozdílem, že neukazují na disk, ale obsahují číslo, které operační systém tomuto souboru přiřadil a podle kterého ho dále rozlišuje). Funkce na práci se soubory opět zpřístupníme vložením hlavičkového souboru &lt;stdio.h&gt;.
</P>

<P>
Jak tedy takové otevření a čtení ze souboru funguje, to pochopíte z následujícího kusu kódu:
</P>
<PRE class="code c">FILE <SPAN class="sy0">*</SPAN>fp<SPAN class="sy0">;</SPAN> <SPAN class="co1">//Nadeklarujeme deskriptor fp</SPAN>
fp <SPAN class="sy0">=</SPAN> fopen<SPAN class="br0">(</SPAN><SPAN class="st0">"soubor.txt"</SPAN><SPAN class="sy0">,</SPAN> <SPAN class="st0">"r"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Otevíráme "soubor.txt" v režimu "r", tedy "pro čtení"</SPAN>
<SPAN class="kw1">if</SPAN><SPAN class="br0">(</SPAN>fp <SPAN class="sy0">==</SPAN> NULL<SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN> <SPAN class="co1">//Osetrime chyby (napr. soubor neexistuje, nebo nemame prava pro cteni)</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Nepodarilo se otevrit soubor!<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	exit<SPAN class="br0">(</SPAN>1<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN>
&nbsp;
<SPAN class="kw4">char</SPAN> retezec<SPAN class="br0">[</SPAN>101<SPAN class="br0">]</SPAN><SPAN class="sy0">;</SPAN>
fgets<SPAN class="br0">(</SPAN>retezec <SPAN class="sy0">,</SPAN> 100<SPAN class="sy0">,</SPAN> fp<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Nacteme 100 bytů (znaků) z fp do retezce retezec</SPAN>
puts<SPAN class="br0">(</SPAN>retezec<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Vytiskneme tento retezec na obrazovku</SPAN>
&nbsp;
fclose<SPAN class="br0">(</SPAN>fp<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Zavreme soubor</SPAN></PRE>

<P>
A tady je například správný postup, jak vypsat celý soubor znak po znaku na obrazovku, všimněte si, že každý znak po celou dobu porovnávám s konstantou <ACRONYM title="End of file">EOF</ACRONYM>, v případě, že jí odpovídá, znamená to, že je soubor na konci (<ACRONYM title="End of file">EOF</ACRONYM> znamená End Of File):
</P>
<PRE class="code c"><SPAN class="kw4">int</SPAN> c<SPAN class="sy0">;</SPAN>
<SPAN class="kw1">while</SPAN><SPAN class="br0">(</SPAN><SPAN class="br0">(</SPAN>c <SPAN class="sy0">=</SPAN> fgetc<SPAN class="br0">(</SPAN>fp<SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN> <SPAN class="sy0">!=</SPAN> EOF<SPAN class="br0">)</SPAN> putc<SPAN class="br0">(</SPAN>c<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN></PRE>

</DIV>
<!-- SECTION "Otevření souboru" [96792-98200] -->
<H2><A name="rezimy_fopen" id="rezimy_fopen">Režimy fopen()</A></H2>
<DIV class="level2">

<P>
Když pomocí fopen() otevíráme soubor, můžeme ho otevřít celkem asi v 9ti režimech. Toto jsou 3 základní:

</P>
<UL>
<LI class="level1"><DIV class="li"> „r“ - read - čtení</DIV>
</LI>
<LI class="level1"><DIV class="li"> „w“ - write - zápis</DIV>
</LI>
<LI class="level1"><DIV class="li"> „a“ - append - zápis (přidání) na konec</DIV>
</LI>
</UL>

<P>

Ke každému režimu můžeme ještě připojit „b“, tedy: „rb“, „wb“, „ab“, to znamená, že se soubory bude zacházeno čistě po binární stránce, tedy že to, co do souboru zapíšete v něm určitě bude a naopak, že přečtete to, co v něm skutečně je. Bez písmenka b dochází k automatické konverzi tzv. line-end kódování, já nechci zabíhat příliš do podrobností, ale v zásadě jde o to, že každá skupina operačních systémů (UNIX + UNIX-like, Windows a staré MAC OSy) ukládají znak odřádkování (Enteru) jinak. Na linuxu je to jen LF, na Windows CR+LF a na starších MAC OSech je to LF+CR, pokud ale v C pracujeme se soubory v textovém režimu (bez „b“), tak s těmito odlišnostmi můžeme pracovat naprosto transparentně (tj. Enter je pokaždé „\n“ nezávisle na systému). Pokud bychom ale například pracovali s nějakým binárním (např. spustitelný soubor, hudba, video), mohlo by takřka náhodné změnění některých bytů na jiné způsobit poměrně velké potíže, proto vždy pracujeme s binárními soubory jinak. U binárních souborů je také špatně, pokud je byte po bytu načítáme do charu, protože ačkoli char je datový typ o velikosti 1B, stejně nemohou být všechny hodnoty korektně interpretovány, proto k načítání bytů z bin. soubori použijeme integer.
</P>

</DIV>
<!-- SECTION "Režimy fopen()" [98201-99789] -->
<H2><A name="funkce_na_cteni_ze_souboru_r" id="funkce_na_cteni_ze_souboru_r">Funkce na čtení ze souboru ("r")</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> fgetc(deskriptor);</DIV>
<UL>
<LI class="level2"><DIV class="li"> Vrati jeden byte (znak) ze souboru</DIV>
</LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"> fgets(retezec, delka, deskriptor);</DIV>
<UL>
<LI class="level2"><DIV class="li"> Precte delka znaku do retezec</DIV>
</LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"> fscanf(deskriptor, “%s“, retezec);</DIV>
<UL>
<LI class="level2"><DIV class="li"> Precete radek do retezec</DIV>
</LI>
</UL>
</LI>
</UL>

</DIV>
<!-- SECTION "Funkce na čtení ze souboru (r)" [99790-100046] -->
<H2><A name="funkce_na_zapis_do_souboru_w_a" id="funkce_na_zapis_do_souboru_w_a">Funkce na zápis do souboru ("w", "a")</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> fputc(byte, deskriptor);</DIV>
<UL>
<LI class="level2"><DIV class="li"> Zapise byte do souboru</DIV>
</LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"> fputs(retezec, deskriptor);</DIV>
<UL>
<LI class="level2"><DIV class="li"> Zapise retezec do souboru</DIV>
</LI>
</UL>
</LI>
<LI class="level1"><DIV class="li"> fprintf(deskriptor, format_retezec, dalsi argumenty);</DIV>
<UL>
<LI class="level2"><DIV class="li"> Jako printf(), ale zapisuje do souboru</DIV>
</LI>
</UL>
</LI>
</UL>

</DIV>
<!-- SECTION "Funkce na zápis do souboru (w, a)" [100047-100324] -->
<H2><A name="predotevrene_soubory" id="predotevrene_soubory">Předotevřené soubory</A></H2>
<DIV class="level2">

<P>
Je dobré vědět, že v C jsou otevřené následující soubory, se kterými pracují funkce jako printf() a pod, když tisknou na obrazovku, nebo načítají z klávesnice, vy toho můžete využít tak, že je zpracujete pomocí funkcí na práci s normálními soubory, nebo je třeba zavřete pro potlačení výstupu. Pak je můžete dokonce opět otevřít a způsobit tak, že všechen výstup vašeho programu, který se normálně provádí na obrazovku bude místo toho uložen do vámi zvoleného souboru. Na druhou stranu nesmíme zapomenout na to, že už nelze zaručit, že znovu půjde otevřít tyto soubory do původního stavu, aby například opět vypisovali na obrazovku. Např. v Linuxu to možné je, v ostatních UNIX-like systémech asi také, ale s jinými takové zkušenost nemám. Na Windows to pravděpodobně možné nebude.

</P>
<UL>
<LI class="level1"><DIV class="li"> stdout - „w“ - stanartní výstup</DIV>
</LI>
<LI class="level1"><DIV class="li"> stderr - „w“ - standartní chybový výstup</DIV>
</LI>
<LI class="level1"><DIV class="li"> stdin - „r“ - standartní vstup</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Předotevřené soubory" [100325-101344] -->
<H2><A name="samostatna_cviceni8" id="samostatna_cviceni8">Samostatná cvičení</A></H2>
<DIV class="level2">
<UL>
<LI class="level1"><DIV class="li"> Napište program, který vypíše celý soubor (určený 1. argumentem) otevřený v textovém módu.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Napište program, který binárně zapíše obsah souboru určeného 1. argumentem do souboru určeného druhým argumentem. Půjde o alternativu programu na kopírování souborů (cp, copy, atd…), tento program vyzkoušejte zkopírováním jiného spustitelného souboru, zvukového záznamu a videa, nebo jiného binárního souboru. Tyto kopie musí mít stejnou velikost a být funkční stejně jako jejich originály.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Napište program, který znak po znaku přečte celý binární soubor a vypíše číselnou hodnotu každého znaku na nový řádek hexadecimálně, desítkově a binárně.</DIV>
</LI>
<LI class="level1"><DIV class="li"> Napište program, který na střídačku binárně čte byte po bytu ze dvou souborů a zapisuje do jednoho souboru. Pokud tedy 1. soubor bude obsahovat byty „AAAAA“ a druhý „BBBBB“, pak bude výsledný soubor obsahovat „ABABABABAB“, potom napište program, který zvládne za byty správně rozdělit tak, aby byly soubory opět použitelné (stejně jako u kopírování).====== Napojení C na další systémy ======</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Samostatná cvičení" [101345-102521] -->
<H2><A name="napojeni_na_webove_aplikace_cgi_a_php" id="napojeni_na_webove_aplikace_cgi_a_php">Napojení na webové aplikace (CGI a PHP)</A></H2>
<DIV class="level2">

<P>
V někerých případech se může stát, že budete potřebovat, aby váš program napsaný v C spolupracoval s vaší webovou aplikací, dnes si představíme dva nejjednodušší způsoby, jak toho docílit. První se bude zabívat <ACRONYM title="Common Gateway Interface">CGI</ACRONYM> rozhraním (Common Gateway Interface) a druhý nám ukáže, jak napojit program na webovou aplikaci pomocí wrapperu napsaného v <ACRONYM title="Hypertext Preprocessor">PHP</ACRONYM>.
</P>

</DIV>
<!-- SECTION "Napojení na webové aplikace (CGI a PHP)" [102522-102951] -->
<H2><A name="common_gateway_interface_cgi" id="common_gateway_interface_cgi">Common Gateway Interface (CGI)</A></H2>
<DIV class="level2">

<P>
<ACRONYM title="Common Gateway Interface">CGI</ACRONYM> je rozhraní, které nám umožní, aby webserver předával požadavek přímo našemu programu. Jaké jsou výhody a nevýhody C proti jiným webovým server-side jazykům (jako <ACRONYM title="Hypertext Preprocessor">PHP</ACRONYM>, JSP, nebo <ACRONYM title="Active Server Pages">ASP</ACRONYM>) je celkem průhledné. C je sice rychlejší, ale musí být zkompilováno pro danou platformu. Nemůžete tedy jednoduše vzít vaší aplikaci, kterou jste do teď provozovali na Linuxu (na procesoru řady x86) a všechny soubory jednoduše uploadnout na HPBSD server (s procesorem PA-RISC), ale budete muset všechny binární soubory ze zdrojových kódů překompilovat pro tuto platformu.
</P>

<P>
Když napíšete a zkompilujete <ACRONYM title="Common Gateway Interface">CGI</ACRONYM> aplikaci, potřebujete ještě webserver, který <ACRONYM title="Common Gateway Interface">CGI</ACRONYM> podporuje a musíte ho nastavit podle instrukcí dle konkrétního serveru, potom nahrajete spustitelné soubory do příslušného adresáře. Nastavení serveru tady rozebírat nebudu.
</P>

<P>
Jaký je tedy rozdíl mezi normálním programem a <ACRONYM title="Common Gateway Interface">CGI</ACRONYM> programem? Jde o obyčejný textový program pro příkazový řádek, s tím rozdílem, že výstup (například text vypsaný pomocí printf()) se nevypisuje na obrazovku, ale do obsahu vrácené webové stránky, nejdříve, ale musíme poslat alespoň minimální <ACRONYM title="Hyper Text Transfer Protocol">HTTP</ACRONYM> hlavičku (pro více informací si přečtěte něco o <ACRONYM title="Hyper Text Transfer Protocol">HTTP</ACRONYM> protokolu), pokud tedy chceme například vygenerovat <ACRONYM title="HyperText Markup Language">HTML</ACRONYM> dokument s nadpisem první úrovně, kód bude vypadat takto:
</P>
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=61" title="St&aacute;hnout snippet" class="mediafile mf_c">cgi-hello.c</A></DT>
<DD><PRE class="code file c"><SPAN class="co2">#include &lt;stdio.h&gt;</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main<SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Content-type: text/html<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//HTTP hlavicka udavajici typ obsahu</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Po posledni hlavicce se posila prazdny radek.</SPAN>
	<SPAN class="co1">//Nyni uz muzeme zahajit vystup:</SPAN>
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"&lt;h1&gt;Hello world!&lt;/h1&gt;<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>
</DD></DL>

<P>
Ještě bychom měli vědět, jak se dostaneme k datům předávaným metodami GET nebo POST. Oba dva typy parametrů jsou předávány jako řetězec ve formátu, v jakém je server dostane od klienta, většinou takový řetězec vypadá například takto (běžný <ACRONYM title="Uniform Resource Locator">URL</ACRONYM> query string):

</P>
<PRE class="code">prvnipromena=224&amp;druha=Zapis%20data&amp;treti&amp;ctvrta=posledni</PRE>

<P>

Pokud jsou data předávána v GETu, nahdete je v proměnné prostředí pojmenované „QUERY_STRING“, pokud tedy například chceme získat a vytisknout celý GET požadavek, uděláme to pomocí funkce getenv() zhruba takto:
</P>
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=62" title="St&aacute;hnout snippet" class="mediafile mf_c">cgi-get.c</A></DT>
<DD><PRE class="code file c"><SPAN class="co2">#include &lt;stdio.h&gt;</SPAN>
<SPAN class="co2">#include &lt;stdlib.h&gt;</SPAN>
&nbsp;
<SPAN class="kw4">int</SPAN> main <SPAN class="br0">(</SPAN><SPAN class="br0">)</SPAN> <SPAN class="br0">{</SPAN>
	<SPAN class="kw4">char</SPAN> <SPAN class="sy0">*</SPAN>get<SPAN class="sy0">;</SPAN>
	get <SPAN class="sy0">=</SPAN> getenv<SPAN class="br0">(</SPAN><SPAN class="st0">"QUERY_STRING"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Získáme pointer na QUERY_STRING</SPAN>
&nbsp;
	<A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"Content-type: text/html<SPAN class="es1">\n</SPAN><SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw1">if</SPAN> <SPAN class="br0">(</SPAN>p <SPAN class="sy0">!=</SPAN> NULL<SPAN class="br0">)</SPAN> <A href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html"><SPAN class="kw3">printf</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st0">"&lt;h1&gt;CGI - GET&lt;/h1&gt;<SPAN class="es1">\n</SPAN>&lt;textarea&gt;%s&lt;/textarea&gt;"</SPAN><SPAN class="sy0">,</SPAN> get<SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN> <SPAN class="co1">//Vytiskneme QUERY_STRING</SPAN>
	<SPAN class="kw1">return</SPAN> <SPAN class="nu0">0</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="br0">}</SPAN></PRE>
</DD></DL>

<P>
Pokud ale chceme získat data z POSTu, budou v přesně stejném tvaru, jako v případě GETu, s tím rozdílem, že budou čekat na standartním vstupu, jinými slovy to znamená, že je můžeme načítat například pomocí funkcí scanf(), nebo getc(), to tady dále rozebírat nebudu, protože to je poměrně základní znalost.
</P>

</DIV>
<!-- SECTION "Common Gateway Interface (CGI)" [102952-105887] -->
<H2><A name="wrapper_v_php" id="wrapper_v_php">Wrapper v PHP</A></H2>
<DIV class="level2">

<P>
<ACRONYM title="Hypertext Preprocessor">PHP</ACRONYM> (Portable Hypertext Preprocesor) je interpretovaný programovací jazyk (podobně, jako <ACRONYM title="Practical Extraction and Report Language">PERL</ACRONYM>, nebo Python), který se dá provozovat například i na webovém serveru. Pro nás je důležité, že obsahuje některé funkce, pomocí kterých se lze odvolávat i na binární spustitelné soubory, požadavky na spustitelný soubor jsou víceméně stejné, jako u <ACRONYM title="Common Gateway Interface">CGI</ACRONYM>, ale s tím rozdílem, že tento soubor nemusí být primárně určen jako webová aplikace, nebo se nacházet ve speciálním adresáři, úplně postačí, když bude mít dobře nastavená práva pro spouštění.
</P>

<P>
Jak toto propojení v <ACRONYM title="Hypertext Preprocessor">PHP</ACRONYM> vytvoříme? Poslouží nám k tomu funkce jako system(), nebo popen() (které se mimochodem chovají stejně, jako jejich jmenovci v Ansi C), shell_exec() a nebo proc_open(). Z následující tabulky pochopíte, co jednotlivé funkce umožňují:

</P>
<UL>
<LI class="level1"><DIV class="li"> system() - spustí program se zadanými parametry a vypíše výstup (stdout)</DIV>
</LI>
<LI class="level1"><DIV class="li"> shell_exec() - spustí program se zadanými parametry a vrátí výstup (stdout)</DIV>
</LI>
<LI class="level1"><DIV class="li"> popen() - otevře program podobně jako například soubor, buď pro čtení stdoutu nebo zápis na stdin programu</DIV>
</LI>
<LI class="level1"><DIV class="li"> proc_open() - dovoluje otevřít program tak, aby bylo možné zároveň pracovat se všemi jeho výstupy i vstupem (stdout, stderr, stdin)</DIV>
</LI>
</UL>

<P>

Jednoduchý <ACRONYM title="Hypertext Preprocessor">PHP</ACRONYM> skript, který nám spustí náš smyšlený program napsaný v C, který může obsluhovat smyšlený teploměr by vypadal například takto:
</P>
<DL class="file">
<DT><A href="http://localhost/doku/doku.php?do=export_code&id=skripta:jazyk_c:compilation&codeblock=63" title="St&aacute;hnout snippet" class="mediafile mf_php">c.php</A></DT>
<DD><PRE class="code file php">&lt;h1&gt;Teploty&lt;/h1&gt;
<SPAN class="kw2">&lt;?php</SPAN>
	<SPAN class="kw1">echo</SPAN><SPAN class="br0">(</SPAN><SPAN class="st0">"&lt;h2&gt;Vevnitř&lt;/h2&gt;<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw1">echo</SPAN><SPAN class="br0">(</SPAN><A href="http://www.php.net/htmlspecialchars"><SPAN class="kw3">htmlspecialchars</SPAN></A><SPAN class="br0">(</SPAN><A href="http://www.php.net/shell_exec"><SPAN class="kw3">shell_exec</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st_h">'./thermo -in'</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">.</SPAN><SPAN class="st0">"<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw1">echo</SPAN><SPAN class="br0">(</SPAN><SPAN class="st0">"&lt;h2&gt;Venku&lt;/h2&gt;<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
	<SPAN class="kw1">echo</SPAN><SPAN class="br0">(</SPAN><A href="http://www.php.net/htmlspecialchars"><SPAN class="kw3">htmlspecialchars</SPAN></A><SPAN class="br0">(</SPAN><A href="http://www.php.net/shell_exec"><SPAN class="kw3">shell_exec</SPAN></A><SPAN class="br0">(</SPAN><SPAN class="st_h">'./thermo -out'</SPAN><SPAN class="br0">)</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">.</SPAN><SPAN class="st0">"<SPAN class="es1">\n</SPAN>"</SPAN><SPAN class="br0">)</SPAN><SPAN class="sy0">;</SPAN>
<SPAN class="sy1">?&gt;</SPAN></PRE>
</DD></DL>

<P>
Všiměte si, že jsem použil ještě funkci <ACRONYM title="Hypertext Preprocessor">PHP</ACRONYM> nazvanou htmlspecialchars(), která zajistí, že například špičaté závorky budou převedeny na příslušné <ACRONYM title="HyperText Markup Language">HTML</ACRONYM> entity, místo toho, aby způsobily nekorektní zobrazení dokumentu. Sám podobný skript používám, abych si mohl přes webové rozhraní vypisovat aktuální informace o serveru (teplota procesoru, disků, volné místo na disku, přihlášení uživatelé, spuštěné procesy, atd…). To je tedy vše, co si o spolupráci programů napsaných v C s vebovými aplikacemi můžeme říct, aniž bychom přesáhli rámec naší hodiny.
</P>

</DIV>
<!-- SECTION "Wrapper v PHP" [105888-108209] -->
<H2><A name="jine_systemy" id="jine_systemy">Jiné systémy</A></H2>
<DIV class="level2">

<P>
Podobně, jako z <ACRONYM title="Hypertext Preprocessor">PHP</ACRONYM> voláme program napsaný v C, můžeme z C také volat jiný program, nebo můžeme například pomocí socketů vytvořit spojení například s naslouchajícím serverem. Propojení dvou programů může také probíhat pomocí roury, nebo pojmenované FIFO (first in, first out) roury.
</P>

</DIV>
<!-- SECTION "Jiné systémy" [108210-108547] -->
<H1><A name="freestyle_coding_contest" id="freestyle_coding_contest">Freestyle Coding Contest</A></H1>
<DIV class="level1">

<P>
<EM>Pozn.: Tato lekce může být použita suplujícím v případě absence vyučujícího, je ale nutné slevit z nároků a říct studentům, aby aplikace upravili tak, aby nemuseli používat znalosti, které ještě nemají, nebo si vymysleli jednodušší zadání, jehož správnost (a především správnost vypracování programu) bude ověřena při první možné příležitosti vyučujícím lektorem.</EM>
</P>

<P>
V poslední lekci jsem si pro vás připravil zadání různých malých (a do jisté míry užitečných) prográmků, které byste se svými znalostmi měli být schopni vytvořit. Protože ale nemusí být úplně průhledné, jak takový program napsat (ačkoli teoretické znalosti byste na to mít měli), v případě nejasností požádejte profesora o pomocnou berličku v místech, která vám nejsou úplně jasná (samozřejmě až po chvilce namáhání hlavy ;). Pokud nemáte žádný vlastní nápad, můžete si vybrat jeden (nebo několik) z následujících projektů:
</P>

</DIV>
<!-- SECTION "Freestyle Coding Contest" [108548-109593] -->
<H2><A name="kalkulator" id="kalkulator">Kalkulátor</A></H2>
<DIV class="level2">

<P>
Pokuste se napsat co nejkomplexnější a nejpřívětivější program na provádění různých druhů výpočtů. Program můžete například doplit i o pokročilé funkce, jako vykreslení grafu (pomocí písmenek) průběhu různých funkcí při různých vstupních hodnotách (stačí například sin()), nebo libovolnou jinou funkci dle zájmu (výpočet obvodu kruhu, nebo cokoli, co ve své kalkulačce chcete mít).
</P>

</DIV>
<!-- SECTION "Kalkulátor" [109594-110047] -->
<H2><A name="interpreter_jednoducheho_jazyka" id="interpreter_jednoducheho_jazyka">Interpreter jednoduchého jazyka</A></H2>
<DIV class="level2">

<P>
Vymyslete si jednoduchý interpretovaný programovací jazyk a napište pro něj interpreter. Stačí například 3-5 příkazů, pro zjednodušení může mít každý příkaz délku 1 znak, nebo řádek. V jednodušší obdobě nemusí jazyk být schopný dělat nic smysluplného, například pokud první písmenko řádku určuje akci a zbytek jsou data, která se mají zpracovat a „P“ znamená vytisknout a „M“ vynásobit dvěmi a vytisknout, může náledující program:

</P>
<PRE class="code">PTento text bude vypsan
CToto je komentar
M23 //toto cislo bude vynasobeno dvěmi a vypsáno</PRE>

<P>

Po zpracování vaším interpreterem například vytvořit následující výpis:

</P>
<PRE class="code">Tento text bude vypsan
46</PRE>

<P>

Co bude jazyk dělat je čistě na vás, může také například do dvojrozměrného pole kreslit čáru (L,P,N,D,T = vlevo, vpravo, nahoru, dolu, tisk) a když narazí na příkaz pro tisk, tak toto „plátno“ vytiskne (vypíše).
</P>

<P>
Tedy program <STRONG>DDDPPPNNLLDT</STRONG> vypíše například toto:

</P>
<PRE class="code">#
####
## #
####</PRE>

<P>

Můžete si samozřejmě doplnit další příkazy (změna písmenka/barvy), nebo napsat něco úplně jiného.
</P>

</DIV>
<!-- SECTION "Interpreter jednoduchého jazyka" [110048-111220] -->
<H2><A name="shell" id="shell">Shell</A></H2>
<DIV class="level2">

<P>
Napište jednoduchý příkazový řádek (podobný například BASHi, nebo CMD) implementujte do něj funkci pro spouštění zadaných příkazů. Na internetu zjistěte, jakým způsobem lze zjistit aktuální adresář a vypisujte ho jako součást výzvy (na začátek řádky). Můžete implementovat i další virtuální příkazy na mazání, přesouvání a kopírování souborů, apod… Záleží opět jen na vaší fantazii.
</P>

</DIV>
<!-- SECTION "Shell" [111221-111679] -->
<H2><A name="mnohojazycna_aplikace" id="mnohojazycna_aplikace">Mnohojazyčná aplikace</A></H2>
<DIV class="level2">

<P>
Napište program, který obsahuje několik jednoduchých textových menu a libovolnou funkčnost (můžete se inspirovat jinými příklady). Veškeré texty v programu se budou načítat ze souboru specifikovaného v jiném (konfiguračním souboru). Vytvořte najméně dva datové soubory s lokalizacemi programu do vašeho mateřského jazyka a libovolného jiného. Soubor s jazykem nastavený v konfiguračním souboru by měl jít dočasně změnit pomocí argumentu programu.
</P>

</DIV>
<!-- SECTION "Mnohojazyčná aplikace" [111680-112200] -->
<H2><A name="engine_textove_hry" id="engine_textove_hry">Engine textové hry</A></H2>
<DIV class="level2">

<P>
Napište engine a alespoň jeden datový soubor pro textovou hru (elektronický gamebook), uživatel bude o pohybu mezi místnostmi této adventury (načtené ze souboru, jehož jméno zadá v parametru) rozhodovat zadáním čísla místnosti, číslo místnosti může odpovídat jedné konkrétní řádce v textovém souboru. Do enginu můžete dodělat možnosti soubojů (pomocí náhodných čísel), nebo kontrolu, jestli hráč dostal skutečně na výběr číslo místnosti, které zadal.
</P>

</DIV>
<!-- SECTION "Engine textové hry" [112201-112733] -->
<H2><A name="primitivni_textovy_editor" id="primitivni_textovy_editor">Primitivní textový editor</A></H2>
<DIV class="level2">

<P>
Program pro CLI (příkazový řádek) přijme jako argumenty režim (R - přečíst (vypsat na obrazovku), W - přečíst a zapsat, nebo A - přečíst a přídat) a jméno souboru, bude ho vypisovat po 15 řádkách (pokaždé počká na enter), až se dostane na konec souboru, tak pokud je pomocí prvního argumentu aktivován režim, který umožňuje zápis do souboru, vypíše řetězec „\n—– NEJAKY TEXT —–\n“ (NEJAKY TEXT budou informace o souboru) a vše, co od té chvíle uživatel napíše na klávesnici zaznamená do souboru (přepíše celý soubor). Uživatel svůj vstup ukončí pomocí programátorem zvolené klávesy stlačené současně s Control (CTRL), nesmí ale jít o kombinace CTRL+C nebo CTRL+D. Pokud uživatel zadá volbu R, program místo toho rovnou skončí.
</P>

<P>
Pokud program argument s názvem souboru neobdrží, automaticky vypíše seznam souborů (pomocí volání system() a příslušného programu - tj. ls, dir,…) a na jméno souboru se dotáže. Pokud soubor neexistuje, nabídne jeho vytvoření. Pokud je zadán první argument, tento soubor zpracuje v daném režimu, v jiném případě se uživatele taktéž zeptá.
</P>

</DIV>
<!-- SECTION "Primitivní textový editor" [112734-113950] -->
<H2><A name="ascii_grafika" id="ascii_grafika">Ascii Grafika</A></H2>
<DIV class="level2">

<P>
Tento program by měl dokázat vykreslovat (alespoň) 3 libovolné různé obrazce, prvním parametrem je určen tvar, druhým znak (barva) a dalšími potřebné parametry (rozměry). Způsob, jakým bude tvar vykreslován a jakým bude prováděn výpočet nechám na vás, důležité je ale, aby se tvar zobrazoval korektně nezávisle na zadaném rozměru. Výstup (u těch opravdu nejjednodušších obrazců) může vypadat například takto:
</P>
<PRE class="code">Čtverec (c):
./grafika c # 4 4
####
#  #
#  #
####

Kruh (k):
./grafika k o 3
 o  o
o    o
 o  o

Trojúhelník (t):
./grafika t A 5
  A
 A A
AAAAA
</PRE>

</DIV>
<!-- SECTION "Ascii Grafika" [113951-114592] -->
<H2><A name="dalsi_napady" id="dalsi_napady">Další nápady</A></H2>
<DIV class="level2">

<P>
Můžete samozřejmě vymyslet a zrealizovat svůj ještě zajímavější nápad, nebo libovolná zadání libovolně modafakovat.
</P>

<P>
Nejlepší programátor (čistota kódu*nápaditost) bude odměněn diplomem „Fr335ty13 C0din9 C0nt35+ - Zlatý byte“ (nebo taky ne ;)…
</P>

</DIV>
<!-- SECTION "Další nápady" [114593-114892] -->
<H1><A name="vysvetlivky" id="vysvetlivky">Vysvětlivky</A></H1>
<DIV class="level1">
<PRE class="code">Akronym - Zkratka vzniklá spojením počátečních písmen slov ve slovním spojení, nebo větě.
BFU - Běžný Franta Uživatel - slangové ozn. pro uživatele bez hlubších znalostí, pravděpodobně to jednou bude váš typický uživatel. Aplikace je nutno přizpůsobovat těmto uživatelům.
CLI - Command Line Interface - Akronym pro příkazový řádek.
IDE - Integrated developing environment - Integrované vývojové prostředí - Zkládá se především z editoru a kompilátoru (případně může obsahovat debugger nebo GUIBuilder).
UI - User Interface - Uživatelské rozhraní - rozhraní, pomocí kterého uživatel komunikuje s aplikací.
GUI - Graphical User Interface - Specifický druh UI využívající grafiku (většinou tzv. okenní aplikace).
C - Programovací jazyk.
Ansi C - Americká norma popisující konvence, které musí dodržet kompilátor. Používá se zároveň i jako označení současné verze jazyka C.
C++ - Programovací jazyk vycházející z jazyka C. Byl rozšířen především o podporu objektů.
Decimální - Desítkový
HexaDecimální - Šestnáctkový
Binární - Dvojkový
Oktální - Osmičkový
Preprocesor kompilátoru - Program, který připravuje zdrojový kód pro kompilátor (maže nepotřebné mezery, komentáře, atd...).
Kompilátor - Program, který převádí zdrojový kód na binární objektový kód.
Assembler - Jazyk symbolických adres. Programovací jazyk využívající přímo instrukce procesoru (jen zapsané čitelnější formou).
Linker - Program vytvářející spustitelný soubor z objektového kódu vytvořeného při kompilaci.
</PRE>

</DIV>
<!-- SECTION "Vysvětlivky" [114893-116564] -->
<H1><A name="prameny" id="prameny">Prameny</A></H1>
<DIV class="level1">

<P>
Tady naleznete seznam zdrojů, které sem (kromě svých vlastních znalostí) použil k napsání těchto skript a které vám důrazně doporučuji si pročíst, nebo je prohledávat při nejasnostech ohledně Ansi C, nebo C jako takového.
</P>

<P>
Povinná četba každého Céčkaře
</P>
<UL>
<LI class="level1"><DIV class="li"> Pavel Herout - Učebnice Jazyka C (Kopp) - I. a II. díl</DIV>
</LI>
<LI class="level1"><DIV class="li"> Jon Erickson - Hacking: umění exploitace (Zoner press)</DIV>
</LI>
</UL>

<P>

Knihovní funkce Ansi C
</P>
<UL>
<LI class="level1"><DIV class="li"> <A href="http://www.java2s.com/Code/C/CatalogC.htm" class="urlextern" title="http://www.java2s.com/Code/C/CatalogC.htm" rel="nofollow">http://www.java2s.com/Code/C/CatalogC.htm</A> - Seznam standartizovaných funkcí s popisem</DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://dione.zcu.cz/studium/doc/lang/ansi-c/" class="urlextern" title="http://dione.zcu.cz/studium/doc/lang/ansi-c/" rel="nofollow">http://dione.zcu.cz/studium/doc/lang/ansi-c/</A> - Západočeská univerzita - seznam funkcí se syntaxí</DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://www.sallyx.org/" class="urlextern" title="http://www.sallyx.org/" rel="nofollow">http://www.sallyx.org/</A> - Několik pěkných článků o C</DIV>
</LI>
<LI class="level1"><DIV class="li"> <A href="http://www.soom.cz/index.php?name=articles/rubrika&sid=3" class="urlextern" title="http://www.soom.cz/index.php?name=articles/rubrika&amp;sid=3" rel="nofollow">http://www.soom.cz/index.php?name=articles/rubrika&amp;sid=3</A> - Různé články o C pro začátečníky</DIV>
</LI>
</UL>

<P>

Všeobecné informace
</P>
<UL>
<LI class="level1"><DIV class="li"> cs.wikipedia.org</DIV>
</LI>
<LI class="level1"><DIV class="li"> en.wikipedia.org</DIV>
</LI>
</UL>

<P>

Všechno ostatní
 * google.com
</P>
<UL>
<LI class="level1"><DIV class="li"> Existují pokročilé techniky googlování, které vám pomohou snázeji najít to, co skutečně hledáte</DIV>
</LI>
</UL>

</DIV>
<!-- SECTION "Prameny" [116565-] --></DIV>


</BODY></HTML>